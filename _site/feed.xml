<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Playfish Blog</title>
    <description>关于个人成长历程、ROS设计 | Carl Zhang，About personal growth, ROS designer. | 这里是 @Playfish 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 14 May 2018 03:42:24 -0700</pubDate>
    <lastBuildDate>Mon, 14 May 2018 03:42:24 -0700</lastBuildDate>
    <generator>Jekyll v3.8.1</generator>
    
      <item>
        <title>【ROS总结】发布ROS2包到ROS版本</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80075689&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在上一总结中，讲述了如何将&lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80039148&quot;&gt;ROS1的包发布到ROS版本&lt;/a&gt;（Indigo、jade、kinetic、lunar等），在这一节中，讲述如何把ROS2的包发送到ROS社区，比如发布到ROS2版本（ardent）。&lt;/p&gt;

&lt;p&gt;这个页面描述了如何准备在公共ROS 2 buildfarm上发布存储库。在你创建了一个包之后，这是将你的包引入到公开可用的Debian软件包(即：你将能够通过apt-get安装包。这个页面包含了ROS 2特定的指令，它取代了在ROS Wiki上的&lt;a href=&quot;http://wiki.ros.org/cn/bloom/Tutorials/FirstTimeRelease&quot;&gt;Bloom发布教程的第2部分&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;注意：早期的ROS 2版本的发布过程主要依赖于&lt;code class=&quot;highlighter-rouge&quot;&gt;git-bloom-release&lt;/code&gt;的子命令&lt;code class=&quot;highlighter-rouge&quot;&gt;bloom-release&lt;/code&gt;，而不是完整的开放版本工作流，所以可能会有问题。&lt;/p&gt;

&lt;h2 id=&quot;对比ros1-bloom不同&quot;&gt;对比ROS1 bloom不同&lt;/h2&gt;

&lt;p&gt;如果你在ROS1之前使用bloom发布过ROS包，ROS2的先决条件和ROS1差不多。然而，ROS 2还没有为你自动进行标记和版本控制的工具（没有等价于&lt;code class=&quot;highlighter-rouge&quot;&gt;catkin_create_changelog&lt;/code&gt;工具）。&lt;/p&gt;

&lt;h3 id=&quot;要求工具&quot;&gt;要求工具&lt;/h3&gt;

&lt;p&gt;对于ROS2的Ardent来说：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;bloom &amp;gt;= 0.6.2&lt;/li&gt;
  &lt;li&gt;catkin_pkg &amp;gt;= 0.4.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;过程&quot;&gt;过程&lt;/h3&gt;

&lt;h4 id=&quot;第一步changelog可选&quot;&gt;第一步：changelog（可选）&lt;/h4&gt;

&lt;p&gt;创建/更新CHANGELOG.rst，使用即将到来的新格式。注意，changelog严格来说是可选的，但它是非常推荐的。&lt;/p&gt;

&lt;p&gt;注意你的changelog格式中的错误可能会导致你的包发布问题。提交并将更改提交给变更日志。&lt;/p&gt;

&lt;h4 id=&quot;第二步标记包版本号&quot;&gt;第二步：标记包版本号&lt;/h4&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package.xml&amp;gt;&lt;/code&gt;中更新包的版本。版本号必须比前一个版本高。对于你的第一个版本，我们建议0.0.1或1.0.0。提交并推动这个变更。&lt;/p&gt;

&lt;p&gt;注意，你不能使用以前使用的版本号(参见下面)。一些包释放到ROS 1和ROS 2，但是由于这个需求，必须使用不同的版本控制系列。ROS包通常不遵循严格的&lt;a href=&quot;https://semver.org/&quot;&gt;语义版本&lt;/a&gt;控制，所以不要过分担心。如果你想了解其他人已经做了什么，请使用ROS 1发布包中的0.x.x或1.x.x系列和ROS 2发布包中的1.x.x或2.x.x系列。&lt;/p&gt;

&lt;h4 id=&quot;第三步标记你的包&quot;&gt;第三步：标记你的包&lt;/h4&gt;

&lt;p&gt;创建一个与你刚刚输入到package.xml中的版本号相匹配的标记，在提交时，会遇到版本号。现在你知道了不能重用版本号的原因——git只允许在存储库中使用给定名称的一个标记。&lt;/p&gt;

&lt;h4 id=&quot;第四步确保你的bloom和catkin_pkg是最新版本&quot;&gt;第四步：确保你的bloom和catkin_pkg是最新版本&lt;/h4&gt;

&lt;p&gt;查看以上版本要求，运行以下命令追踪当前版本：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install python-catkin-pkg python-bloom 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;第五步设置ros-2环境变量&quot;&gt;第五步：设置ROS 2环境变量&lt;/h4&gt;

&lt;p&gt;ROS 2使用的是全新的存储库，该版本的所有索引保存在https://github.com/ros2/rosdistro，forked该存储库。你可以通过设置ROSDISTRO_INDEX_URL环境变量来配置bloom。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ROSDISTRO_INDEX_URL='https://raw.githubusercontent.com/ros2/rosdistro/ros2/index.yaml'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;导出这个之后，你将能够在你的bloom-release终端命令中使用ROS 2发行版的&lt;code class=&quot;highlighter-rouge&quot;&gt;ardent&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bouncy&lt;/code&gt;等名称。&lt;/p&gt;

&lt;h3 id=&quot;下一步&quot;&gt;下一步&lt;/h3&gt;

&lt;p&gt;现在，你的存储库设置完毕。你已经手动完成ROS 2在&lt;a href=&quot;http://wiki.ros.org/cn/bloom/Tutorials/PrepareUpstream&quot;&gt;这个界面&lt;/a&gt;的内容&lt;/p&gt;

&lt;p&gt;返回到ROS Wiki上的&lt;a href=&quot;http://wiki.ros.org/cn/bloom/Tutorials/FirstTimeRelease&quot;&gt;Bloom发布&lt;/a&gt;教程，并继续“创建一个发布存储库”。&lt;/p&gt;

</description>
        <pubDate>Wed, 25 Apr 2018 04:40:44 -0700</pubDate>
        <link>http://localhost:4000/2018/04/25/releaseros2-into-rosdistro/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/25/releaseros2-into-rosdistro/</guid>
        
        <category>ROS2</category>
        
        <category>Release</category>
        
        
      </item>
    
      <item>
        <title>【ROS总结】发布ROS1包之文档编写</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80041201&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在上一节中，讲述了如何发布一个包到ROS社区，这一节将讲述，如何在wiki界面编写ROS包说明文档、教程。&lt;/p&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;登录wiki官网，创建界面编辑账号&lt;/li&gt;
  &lt;li&gt;向ROS社区提交wiki页面编辑权限，取得白名单&lt;/li&gt;
  &lt;li&gt;编辑ROS包文档&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;创建wiki账号&quot;&gt;创建wiki账号&lt;/h2&gt;

&lt;p&gt;登录wiki.ros.org，选择登录，创建账户&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-with-document/wiki_login.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入用户名密码
&lt;img src=&quot;/img/in-post/release-ros1-with-document/wiki_create_account.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建完成后，选择登录，登录成功会将显示：
&lt;img src=&quot;/img/in-post/release-ros1-with-document/wiki_whitelists.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击界面获取白名单。&lt;/p&gt;

&lt;h2 id=&quot;wiki白名单&quot;&gt;wiki白名单&lt;/h2&gt;

&lt;p&gt;在github上，登录当前github账号，在白名单注册界面：https://github.com/ros-infrastructure/roswiki/issues/139&lt;/p&gt;

&lt;p&gt;发布请求，比如我的wiki用户为playfish，输入，comment即可。
&lt;img src=&quot;/img/in-post/release-ros1-with-document/get_whitelists.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果一切正常，大家可以登录http://wiki.ros.org/UserGroup，查看自己的名字是否加入。&lt;/p&gt;

&lt;h2 id=&quot;编辑文档&quot;&gt;编辑文档&lt;/h2&gt;

&lt;p&gt;现在编写自己ROS包的使用文档，该文档地址应当在package.xml里面表明，比如我的cht10_node包的package.xml地址为：
&lt;img src=&quot;/img/in-post/release-ros1-with-document/package_xml.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此，输入当前第一个网址 http://ros.org/wiki/cht10_node&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-with-document/package_template.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击packageTemplate，来创建界面。
&lt;img src=&quot;/img/in-post/release-ros1-with-document/write_wiki.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在packageHeader中添加自己的cht10_node包名，该界面会自动链接到cht10_node包。&lt;/p&gt;

&lt;p&gt;创建完成后，即可生成界面，文档编辑结束。&lt;/p&gt;

</description>
        <pubDate>Sun, 22 Apr 2018 11:35:30 -0700</pubDate>
        <link>http://localhost:4000/2018/04/22/releaseros1-with-document/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/22/releaseros1-with-document/</guid>
        
        <category>ROS1</category>
        
        <category>Release</category>
        
        <category>Document</category>
        
        <category>wiki</category>
        
        
      </item>
    
      <item>
        <title>【ROS总结】发布ROS1包到ROS版本</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80039148&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在ROS开发过程中，想要发布自己的包贡献到ROS社区，也就是想要自己的包可以通过apt-get的形式进行下载，这样可以避免每次源码编译的时候会遇到很多坑的情况，不过想要发布ROS包到ROS社区需要如下能力：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;长期维护能力：ROS包会一直迭代更新，因此自己的包也应具有长期维护能力，当然，稳定版本后可以不用长期维护。&lt;/li&gt;
  &lt;li&gt;开源精神：因为ROS包遵循BSD协议，会要求将包开源后才可以上传到ROS社区，所以将自己的包发布到ROS社区，最好有开源精神。&lt;/li&gt;
  &lt;li&gt;文档更新：包的更新也伴随这文档更新，当然也不是绝对的，不过最好有包的使用文档，也就是wiki上。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果以上的可以做到，那么，恭喜你，可以作为开源成员加入到ROS大家庭来，开源自己代码，共享社区。&lt;/p&gt;

&lt;p&gt;本教程只是单纯的介绍如何发布自己的包到ROS社区，并且，发布后如何通过apt-get获取下载，关于文档界面编写，也就是wiki说明，会在后面进行说明。&lt;/p&gt;

&lt;p&gt;一般发布自己ROS包有如下步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;具有github账号与要发布的存储库地址，发布存储库(bloom-release生成的包路径)，wiki白名单(文档界面做准备)&lt;/li&gt;
  &lt;li&gt;发布前准备工作，bloom安装(ROS1推荐使用bloom-release进行一键操作)&lt;/li&gt;
  &lt;li&gt;同步到ROS社区&lt;/li&gt;
  &lt;li&gt;等待ROS社区的ROS包版本迭代&lt;/li&gt;
  &lt;li&gt;编辑wiki文档教程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上步骤完成后，就可以进行apt-get形式下载自己的包了。假如自己的包为cht10_node，那么可以使用如下命令进行安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install ros-&amp;lt;rosdistro&amp;gt;-cht10-node 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中将&lt;rosdistro&gt;替换成自己的ROS版本，也就是自己的包发布到的ROS版本中，比如自己的包发布到了kinetic中，那么就是：&lt;/rosdistro&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo  apt-get  install ros-kinetic-cht10-node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意：并不是自己把包发布到ROS社区就等于所有的ROS版本都可以下载，只有发布到对应ROS版本才可以。也就是说要想把自己的包发布到ROS所有版本，必须把自己的包发布到所有的版本中，比如Indigo、Jade、Kinetic、Luna、Melodic中。&lt;/p&gt;

&lt;p&gt;ROS发布需要bloom-release包，我已经将ROS的bloom-release包如何使用翻译到wiki上，大家可以查看教程&lt;/p&gt;

&lt;p&gt;http://wiki.ros.org/cn/bloom&lt;/p&gt;

&lt;p&gt;或者查看英文教程：&lt;/p&gt;

&lt;p&gt;http://wiki.ros.org/bloom&lt;/p&gt;

&lt;p&gt;以后会编写如何发布ROS2的包到ROS社区教程。&lt;/p&gt;

&lt;p&gt;大家也可以看Mastering ROS for Robotics Programming中的Maintaining the ROS package 部分。&lt;/p&gt;

&lt;p&gt;Mastering ROS for Robotics Programming书籍下载：https://download.csdn.net/download/u011118482/10402380 (包含英文和中文翻译)。&lt;/p&gt;

&lt;p&gt;没有0积分下载，大家也可以进入ROS群进行下载。&lt;/p&gt;

&lt;h2 id=&quot;发布前的准备&quot;&gt;发布前的准备&lt;/h2&gt;

&lt;h3 id=&quot;创建github存储库&quot;&gt;创建github存储库&lt;/h3&gt;

&lt;p&gt;登录http://github.com/，创建自己的github账号，创建完成后，创建要发布的ROS存储库，例如包名为之前教程的cht10_node，那么创建cht10_node目录。&lt;/p&gt;

&lt;p&gt;我的存储库为：https://github.com/Playfish/cht10_node&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/cht10_repo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建完成后，上传自己的代码到github的cht10_node存储库中。完成如上图。&lt;/p&gt;

&lt;p&gt;注意：发布ROS包应有如下内容，否则无法发布：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CHANGELOG.rst：必须有该文件，该文件内容，可以查看我写的，格式一般为包+版本(日期)+分隔符+修订日志&lt;/li&gt;
  &lt;li&gt;package.xml：内容必须有maintainer子项，版本号必须与CHANGELOG中的版本一致，比如都为0.0.1，包名也一样。&lt;/li&gt;
  &lt;li&gt;tag：版本标记。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;生成tag用于以下发布ROS包追踪：&lt;/p&gt;

&lt;p&gt;点击当前界面上的release按钮，创建一个release tag：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/cht10_release.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;保存。&lt;/p&gt;

&lt;h3 id=&quot;创建github-release存储库&quot;&gt;创建github release存储库&lt;/h3&gt;

&lt;p&gt;创建要发布的ROS完成后，为ROS包创建生成的release存储库，我创建的名为cht10_node_release，最好创建为包名_release。这个存储库为空即可，必须勾选初始化ReadeMe.md选项，生成的包版本更新日志将存放在这里。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/cht10_release_repo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完成后即可，不用再管这个存储库，后期发布完成后，可以查看内容。&lt;/p&gt;
&lt;h3 id=&quot;fork-ros社区版本包存储库&quot;&gt;fork ROS社区版本包存储库&lt;/h3&gt;

&lt;p&gt;保证自己的github账号处于登录状态，点击：http://github.com/ros/rosdistro 。随后点击fork。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/fork_rosdistro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完成后，可以看到自己有了rosdistro存储库：
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/playfish_rosdistro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;发布ros包&quot;&gt;发布ROS包&lt;/h2&gt;
&lt;p&gt;发布前的准备完成后，在自己的Ubuntu下，安装bloom_release包，安装命令如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install python-bloom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装完成后，使用如下命令进行发布：&lt;/p&gt;

&lt;p&gt;以下配置只会在第一次产生。&lt;/p&gt;

&lt;p&gt;运行以下命令进行发布与配置ROS Release包，比如把cht10_node发布到kinetic版本上：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bloom-release --rosdistro kinetic --track kinetic cht10_node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中–rosdistro后的选项为发布到kinetic版本，–track选项为追踪选项，默认为ROS分布式版本，最后的cht10_node为当前存储库名称。&lt;/p&gt;

&lt;p&gt;运行命令产生如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入之前创建的发布的release存储库：https://github.com/Playfish/cht10_node_release.git&lt;/p&gt;

&lt;p&gt;选择Y确定创建追踪。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入当前存储库名称：cht10_node&lt;/p&gt;

&lt;p&gt;输入当前存储库地址：https://github.com/Playfish/cht10_node.git&lt;/p&gt;

&lt;p&gt;随后一路按下回车为默认选项。直到遇到输入用户名、密码为止，在此过程中会遇到很多次输入账号密码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入github账号密码，回车。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;产生debian配置文件：y&lt;/p&gt;

&lt;p&gt;输入当前github用户名密码继续。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;产生debian包后，输入用户名密码发布tag。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;编辑当前ROS包另一个配置，文档配置以及版本状态，输入默认即可。&lt;/p&gt;

&lt;p&gt;注意：turn on pull request testing选择默认为N，如果选择y需要额外配置，不需要打开，我这里是为以后做准备。&lt;/p&gt;

&lt;p&gt;额外的配置查看：https://github.com/ros/rosdistro/pull/17576&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;向rosdistro存储库的kinetic目录下的分布式文件添加当前包内容。&lt;/p&gt;

&lt;p&gt;随后向rosdistro存储库提交请求，输入当前github账号密码。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;生成请求日志。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完成后，将提示已经发布完成请求，大家可以点击最后的链接查看当前请求。&lt;/p&gt;
&lt;h2 id=&quot;确认工作&quot;&gt;确认工作&lt;/h2&gt;

&lt;p&gt;请求完成后，大家打开之前创建的空白发布存储库，可以看到已经生成了很多生成deb包的规则文件，例如我的：&lt;/p&gt;

&lt;p&gt;https://github.com/Playfish/cht10_node_release.git&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/cht10_release_fill.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大家可以到https://github.com/ros/rosdistro/pulls，查看发布情况。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/report_rosdistro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果一切正常，ROS维护人员将合并当前请求，合并完成后。&lt;/p&gt;

&lt;p&gt;到 讨论论坛中https://discourse.ros.org/查看当前版本下的包迭代情况，一般为一个月ROS包版本迭代一次。&lt;/p&gt;

&lt;p&gt;迭代完成后，可以看到自己的包已经存放到了http://packages.ros.org下。&lt;/p&gt;

&lt;p&gt;使用apt-get update 更新后，可以下载自己的包了，比如我的包可以用如下命令下载：&lt;/p&gt;

&lt;p&gt;sudo  apt-get  install  ros-kinetic-cht10-node&lt;/p&gt;

&lt;p&gt;ROS包的发布过程这一节告一段落，下一步讲述如何&lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80041201&quot;&gt;编辑cht10_node生成的wiki文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;注意，如果要生成wiki文档，需要在package.xml里面添加url指向wiki。&lt;/p&gt;

</description>
        <pubDate>Sun, 22 Apr 2018 10:48:13 -0700</pubDate>
        <link>http://localhost:4000/2018/04/22/releaseros1-into-rosdistro/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/22/releaseros1-into-rosdistro/</guid>
        
        <category>ROS1</category>
        
        <category>Release</category>
        
        
      </item>
    
      <item>
        <title>【ROS总结】点激光扫描仪数据发布（驱动编写）</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/78632555&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在使用ROS的过程中，不可避免的会遇到要自己手动编写驱动、节点、行为库、服务、消息等内容，尤其是需要一些传感器，而所需传感器没有相关ROS驱动时，下面将讲述的是在使用的传感器中，没有ROS驱动时，我们将如何使用该传感器。&lt;/p&gt;

&lt;p&gt;在接下来的博客中将根据本身经验来编写一些ROS相关内容，权当是作为记忆来分享。&lt;/p&gt;

&lt;h2 id=&quot;ros驱动点激光扫描仪&quot;&gt;ROS驱动——点激光扫描仪&lt;/h2&gt;

&lt;p&gt;下面将讲述使用ROS官方未有的传感器来作为样例，我使用的是莱旭光电的CHT-10点激光传感器作为 介绍，首先这款传感器通信协议部分比较简单，基本上打开串口就可以读出数据，在将数据进行转换就可以得到想要的距离，比较方便，免去复杂的部分，对教程也有帮助，毕竟教程主要讲述的是ROS驱动部分。&lt;/p&gt;

&lt;p&gt;相关ROS驱动代码可以在github上找到进行下载：https://github.com/Playfish/cht10_node&lt;/p&gt;

&lt;p&gt;CHT-10是点激光，扫描范围是0.05-10m，真实的应该是0.15-10m，10m未测试，不过0.15盲区还是有的。&lt;/p&gt;

&lt;p&gt;下图是CHT-10的通信协议部分介绍：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/write-laserscan-publisher/laserscan_protocol.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到想要的数据在9~12位（四字节），得到的数据需要除以1000才能得到真实的距离（米），ROS消息中基本单位是米。&lt;/p&gt;

&lt;h3 id=&quot;消息选定&quot;&gt;消息选定&lt;/h3&gt;

&lt;p&gt;关于选择什么消息作为该传感器的ROS消息，这个相对来说不是很重要，不过作为通用项来说，尽量向通用靠近（即使用ROS官方消息定义，而不是自己定义消息）。目前激光消息的话，有两个选择，第一个是sensor_msgs/LaserScan消息类型，不过该消息类型适合有角度的传感器，即180°或360°的2D雷达或激光，而目前使用的激光是单点类型，和激光笔差不多，只有一个点，那么可以选择sensor_msgs/Range消息类型，该消息类型适用于超声波传感器、红外传感器单点类型，CHT-10就用这个类型。&lt;/p&gt;

&lt;p&gt;关于该消息：可以查看&lt;a href=&quot;docs.ros.org/api/sensor_msgs/html/msg/Range.html&quot;&gt;sensor_msgs/Range&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;

&lt;p&gt;传感器选型选定、通信消息选定，那么接下来还需要做：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Frame_id：Frame在ROS中作用至关重要，消息将和TF绑定才可以读取数据，在这里作为通用可配置，暂定内容为：laser，用户可自定义设置（通过ROS Parameters设置）。&lt;/li&gt;
  &lt;li&gt;串口：避免和其他传感器串口冲突，因此在这里预留出一个串口设置参数，用户可以自定义设置（通过ROS Parameters设置）。&lt;/li&gt;
  &lt;li&gt;话题：消息内容需要通过话题发布，并且话题需要唯一，不然容易崩溃，在这里选择话题为“range”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然以上部分可以不考虑，这个是作为通用型需要考虑的，暂时可以先忘记以上部分，下面开启代码部分&lt;/p&gt;

&lt;h3 id=&quot;测试代码编写&quot;&gt;测试代码编写&lt;/h3&gt;

&lt;p&gt;在这部分，主要先编写测试代码，如果测试代码无问题，就可以写到node中，测试代码和ROS无关系，只是通过串口读取数据，并且在终端显示出来，整体思路如下：&lt;/p&gt;

&lt;p&gt;传感器选择 -&amp;gt; 测试程序测试（类似串口助手） -&amp;gt; ROS node绑定（将测试程序读取部分加入到ROS中） -&amp;gt; 将node加入到nodelet中封装&lt;/p&gt;

&lt;p&gt;下面是测试程序部分，也可以在cht10_node/test中找到，名为&lt;a href=&quot;https://github.com/Playfish/cht10_node/blob/master/test/test_cht10.cpp&quot;&gt;test_cht10.cpp&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #include &amp;lt;string&amp;gt;  
    #include &amp;lt;cht10_node/seiral_func.hpp&amp;gt;  
    #include &amp;lt;cstdlib&amp;gt;  
      
    #include &amp;lt;iostream&amp;gt;  
    #include &amp;lt;stdint.h&amp;gt;  
    #define BUFSIZE 17  
      
    int main(int argc, char** argv){  
      cht10_seiral_func::Cht10Driver cht10driver_;  
      
      std::string serialNumber_;  
      serialNumber_ = &quot;/dev/ttyUSB0&quot;;  
      int baudRate_ = 115200;  
      
      std::stringstream ostream;  
      int fd, len, rcv_cnt;  
      bool success_flag;  
      char buf[40], temp_buf[BUFSIZE],result_buf[BUFSIZE];  
      int laser_data=0;  
      char data_buf[4];  
      rcv_cnt = 0;  
      success_flag = false;  
      memset(buf, 0xba, sizeof(buf));  
      memset(temp_buf, 0xba, sizeof(temp_buf));  
      memset(result_buf, 0xba, sizeof(result_buf));  
      
      fd = open(serialNumber_.c_str(), O_RDWR | O_NOCTTY | O_NDELAY );  
      if(fd &amp;lt; 0){  
        std::cout&amp;lt;&amp;lt;&quot;Open Serial: &quot;&amp;lt;&amp;lt;serialNumber_.c_str()&amp;lt;&amp;lt;&quot; Error!&quot;;  
        exit(0);  
      }  
        
      cht10driver_.UART0_Init(fd,baudRate_,0,8,1,'N');  
      while(1){  
        len = cht10driver_.UART0_Recv(fd, buf,40);  
        if(len&amp;gt;0){  
          for(int i = 0; i &amp;lt; len; i++){  
            if(rcv_cnt&amp;lt;=BUFSIZE){    
              result_buf[rcv_cnt++] = buf[i];  
              if(rcv_cnt == BUFSIZE){  
                success_flag = true;  
              }  
            }//end if  
            else{  
              /**** 
              *  checkout received data 
              */  
    //          std::cout&amp;lt;&amp;lt;&quot;Received data, with :[&quot;;  
    //          for(int j=0;j&amp;lt;BUFSIZE;j++){  
    //            printf(&quot;%c &quot;,(unsigned char) result_buf[j]);  
    //          }  
    //          printf(&quot;] \n&quot;);  
              success_flag = false;  
      
              for(int count = 0; count &amp;lt; 4; count++){  
                data_buf[count] = result_buf[9+count];  
              }  
              sscanf(data_buf, &quot;%x&quot;, &amp;amp;laser_data);  
              std::cout&amp;lt;&amp;lt;&quot;sensor data:&quot;&amp;lt;&amp;lt;laser_data&amp;lt;&amp;lt;&quot;, Distance: &quot;&amp;lt;&amp;lt;(double)laser_data/1000&amp;lt;&amp;lt;std::endl;  
              /**** 
               *  data writing end 
               */  
              if('~' == buf[i]){  
                rcv_cnt = 0;  
                result_buf[rcv_cnt++] = buf[i];  
              }  
            }//end else  
          }//end for      
        }  
      }  
      
        
    }  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我将串口部分封装成一个类名为&lt;code class=&quot;highlighter-rouge&quot;&gt;Cht10Driver&lt;/code&gt;，该类包含串口读/写部分、初始化。&lt;/p&gt;

&lt;p&gt;通过使用&lt;code class=&quot;highlighter-rouge&quot;&gt;catkin_make&lt;/code&gt;可以得到一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;test_cht10&lt;/code&gt;的可执行文件，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;./test_cht10&lt;/code&gt;可以运行，将CHT-10插入到电脑上，并且电脑只有一个ttyUSB0，就可以读取数据，数据将显示为sensor data: 传感器毫米数据， Distance: 传感器米数据。&lt;/p&gt;

&lt;h3 id=&quot;ros驱动编写&quot;&gt;ROS驱动编写&lt;/h3&gt;

&lt;p&gt;上部分讲述了测试程序编写，主要作用是通过串口读取传感器数据，那么得到传感器数据之后，就可以将传感器数据填充到ROS消息中，然后通过话题形式发布出去，如下是将传感器数据填充到ROS消息并封装成nodelet类的主要部分：&lt;/p&gt;

&lt;p&gt;完整代码可以查看： &lt;a href=&quot;https://github.com/Playfish/cht10_node/blob/master/src/cht10_node.cpp&quot;&gt;cht10_node.cpp&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    /** 
     * @file /Cht10_serial_func/src/Cht10_serial_func.cpp 
     * 
     * @brief Implementation for dirver with read data from Cht10 nodelet 
     * 
     * @author Carl 
     * 
     **/  
      
    /***************************************************************************** 
     ** Includes 
     *****************************************************************************/  
    #include &amp;lt;string&amp;gt;  
    #include &amp;lt;ros/ros.h&amp;gt;  
    #include &amp;lt;std_msgs/String.h&amp;gt;  
    #include &amp;lt;nodelet/nodelet.h&amp;gt;  
    #include &amp;lt;ecl/threads/thread.hpp&amp;gt;  
    #include &amp;lt;sensor_msgs/LaserScan.h&amp;gt;    
    #include &amp;lt;sensor_msgs/Range.h&amp;gt;    
    #include &amp;lt;pluginlib/class_list_macros.h&amp;gt;  
    #include &amp;lt;cht10_node/seiral_func.hpp&amp;gt;  
      
      
    namespace cht10_seiral_func{  
      
    class Cht10Func : public nodelet::Nodelet{  
    #define BUFSIZE 17  
    #define SCALE 1000  
      
    public:  
      Cht10Func() : shutdown_requested_(false),serialNumber_(&quot;/dev/USB0&quot;),frame_id(&quot;laser&quot;){}  
      
      ~Cht10Func(){  
        NODELET_DEBUG_STREAM(&quot;Waiting for update thread to finish.&quot;);  
        shutdown_requested_ = true;  
        update_thread_.join();  
      }  
      
      virtual void onInit(){  
      
        ros::NodeHandle nh = this-&amp;gt;getPrivateNodeHandle();  
        std::string name = nh.getUnresolvedNamespace();  
        nh.getParam(&quot;serialNumber&quot;, serialNumber_);  
        nh.getParam(&quot;baudRate&quot;, baudRate_);  
        nh.getParam(&quot;frame_id&quot;, frame_id);  
        rcv_cnt = 0;  
        success_flag = 0;  
      
        fd = open(serialNumber_.c_str(), O_RDWR | O_NOCTTY | O_NDELAY );  
        if(fd &amp;lt; 0){  
          ROS_ERROR_STREAM(&quot;Open Serial: &quot;&amp;lt;&amp;lt;serialNumber_.c_str()&amp;lt;&amp;lt;&quot; Error!&quot;);  
          exit(0);  
        }  
      
        int countSeq=0;  
        scan_pub = nh.advertise&amp;lt;sensor_msgs::Range&amp;gt;(&quot;range&quot;,100);  
        memset(buf, 0, sizeof(buf));  
        memset(temp_buf, 0, sizeof(temp_buf));  
        memset(result_buf, 0, sizeof(result_buf));  
        Cht10driver_.UART0_Init(fd,baudRate_,0,8,1,'N');  
        ROS_INFO_STREAM(&quot;Open serial: [&quot;&amp;lt;&amp;lt; serialNumber_.c_str() &amp;lt;&amp;lt;&quot; ] successful, with idex: &quot;&amp;lt;&amp;lt;fd&amp;lt;&amp;lt;&quot;.&quot;);  
        NODELET_INFO_STREAM(&quot;Cht10Func initialised. Spinning up update thread ... [&quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &quot;]&quot;);  
        update_thread_.start(&amp;amp;Cht10Func::update, *this);  
      }  
      
      double data_to_meters(int &amp;amp;data, int scale){  
        return (double)data/scale;  
      }  
      
      void publish_scan(ros::Publisher *pub,  
                        double nodes, ros::Time start,  
                        std::string frame_id){  
      
        float final_range;  
        sensor_msgs::Range range_msg;  
        range_msg.field_of_view = 0.05235988;  
        range_msg.max_range = 10.0;  
        range_msg.min_range = 0.05;  
        range_msg.header.frame_id = frame_id;  
        range_msg.radiation_type = sensor_msgs::Range::INFRARED;  
        if(nodes &amp;gt; range_msg.max_range){  
          final_range = std::numeric_limits&amp;lt;float&amp;gt;::infinity();  
        }else if(nodes &amp;lt; range_msg.min_range){  
          final_range = -std::numeric_limits&amp;lt;float&amp;gt;::infinity();  
        }else{  
          final_range = nodes;  
        }  
        range_msg.header.stamp = start;  
        range_msg.header.seq = countSeq;  
        range_msg.range = final_range;  
        scan_pub.publish(range_msg);  
      
      }  
      
      bool get_scan_data(){  
        len = Cht10driver_.UART0_Recv(fd, buf,40);  
        if(len&amp;gt;0){  
          for(int i = 0; i &amp;lt; len; i++){  
            if(rcv_cnt&amp;lt;=BUFSIZE){    
              result_buf[rcv_cnt++] = buf[i];  
              if(rcv_cnt == BUFSIZE){  
                success_flag = true;  
              }  
            }//end if  
            else{  
              /**** 
              *  checkout received data 
              */  
              success_flag = false;  
               for(int count = 0; count &amp;lt; 4; count++){  
                data_buf[count] = result_buf[9+count];  
              }  
              sscanf(data_buf, &quot;%x&quot;, &amp;amp;laser_data);  
                
              //std::cout&amp;lt;&amp;lt;&quot;sensor data:&quot;&amp;lt;&amp;lt;laser_data&amp;lt;&amp;lt;std::endl;  
      
              /**** 
               *  data writing end 
               */  
              if('~' == buf[i]){  
                rcv_cnt = 0;  
                result_buf[rcv_cnt++] = buf[i];  
              }  
            }//end else  
          }//end for      
        }  
      }  
    private:  
      void update(){  
        rcv_cnt = 0;  
        success_flag = 0;  
        laser_data = 0;  
        ros::Rate spin_rate(50);  
        memset(buf, 0, sizeof(buf));  
        memset(temp_buf, 0, sizeof(temp_buf));  
        memset(result_buf, 0, sizeof(result_buf));  
        ROS_INFO_STREAM(&quot;Begin receive data from &quot;&amp;lt;&amp;lt;serialNumber_.c_str()&amp;lt;&amp;lt;&quot;, with idex:&quot;&amp;lt;&amp;lt;fd&amp;lt;&amp;lt;&quot;.&quot;);  
        fd = open(serialNumber_.c_str(), O_RDWR | O_NOCTTY | O_NDELAY );  
        Cht10driver_.UART0_Init(fd,baudRate_,0,8,1,'N');  
        while (! shutdown_requested_ &amp;amp;&amp;amp; ros::ok())  
        {  
          start_scan_time = ros::Time::now();  
          success_flag = get_scan_data();  
                
          //Send data  
          publish_scan(&amp;amp;scan_pub, data_to_meters(laser_data,SCALE),  
                           start_scan_time, frame_id);  
          spin_rate.sleep();  
      
          countSeq++;  
        }  
      
        ROS_INFO_STREAM(&quot;Shotdown and close serial: &quot;&amp;lt;&amp;lt;serialNumber_.c_str()&amp;lt;&amp;lt;&quot;.&quot;);  
        Cht10driver_.UART0_Close(fd);  
      }  
    private:  
      int fd, len, rcv_cnt;  
      int success_flag;  
      char buf[40], temp_buf[BUFSIZE],result_buf[BUFSIZE];  
        
      Cht10Driver Cht10driver_;  
      ecl::Thread update_thread_;  
      bool shutdown_requested_;  
      ros::Publisher scan_pub;  
      int laser_data;  
      char data_buf[4];  
      // ROS Parameters  
      std::string serialNumber_;  
      int baudRate_;  
      int countSeq;  
        
      std::string frame_id;  
      
      ros::Time start_scan_time;  
    };  
      
    } //namespace Cht10_serial_func  
    PLUGINLIB_EXPORT_CLASS(cht10_seiral_func::Cht10Func,  
    nodelet::Nodelet);  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中get_scan_data()函数，就是测试代码内容，得到数据后将数据发送到publish_scan()函数中，就可以发布传感器数据了。&lt;/p&gt;

&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;

&lt;p&gt;代码完成后，按照格式进行编写CMakeList、package文件，运行catkin_make就可以得到名为cht10_node.so动态库，运行launch文件即可加载，命令如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch cht10_node standalone.launch 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果一切成才，运行rostopic list 可以得到/range话题。&lt;/p&gt;

&lt;p&gt;使用rostopic echo /range就可以得到传感器的ROS消息内容，包括传感器距离。&lt;/p&gt;

&lt;p&gt;或者直接运行&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch cht10_node view_range.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;就可以看到图形化形式为传感器数据。&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Nov 2017 09:05:58 -0800</pubDate>
        <link>http://localhost:4000/2017/11/25/write-laserscan-publisher/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/25/write-laserscan-publisher/</guid>
        
        <category>ROS1</category>
        
        <category>Release</category>
        
        <category>driver</category>
        
        
      </item>
    
      <item>
        <title>ros_arduino_bridge使用总结</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/77528798&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;关于ROS和Arduino通信方式，刚开始大多使用的是rosserial_arduino这个库，随后又诞生了一个新的库名为ros_arduino_bridge，两者对比如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://wiki.ros.org/rosserial_arduino&quot;&gt;rosserial_arduino&lt;/a&gt;：由于将Arduino内的程序写成ros节点形式，所以能够快速的通过ROS控制Arduino，并且可以忽略通信协议层，与之相同的还有rosserial_stm32f1库，但是由于将Arduino作为ROS节点，不可避免的产生通信延时较大的问题，而且运行该库是通过rosserial_python包内的serial_node.py启动，该脚本使用了tcpip协议，有点大材小用，uno速率会跟不上，导致启动过程中一崩溃很难在连接上的问题，学习ROS可以使用。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://wiki.ros.org/rosserial_arduino_bridge&quot;&gt;ros_arduino_bridge&lt;/a&gt;：是自定义通信协议方式来与Arduino进行通信，和大多数控制形式一致，将通信协议固定可以让初学者在使用过程中了解通信协议，由于是自定义通信协议形式，可以即插即用，和rosserial_arduino有本质差别，不过在使用过程中需要自己配置，所以需要有一定的arudino编程基础，早期的EAI dashgo D1采用的就是这种形式，使用这个库可以缩短底盘开发时间，并且Arduino有很多开源包供使用，会相对轻松一些。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于如何使用rosserial_arduino_bridge，作者在github的&lt;a href=&quot;https://github.com/hbrobotics/ros_arduino_bridge/blob/indigo-devel/README.md&quot;&gt;Readme&lt;/a&gt;中写的很清楚，当然，是使用英文编写，如果大家想要查看中文，&lt;a href=&quot;blog.csdn.net/github_30605157/article/details/51344150/&quot;&gt;这里&lt;/a&gt;是一个很好的方式，我做的小车就是参考这篇博客，写的很清楚。&lt;/p&gt;

&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;
&lt;h3 id=&quot;编码器&quot;&gt;编码器&lt;/h3&gt;

&lt;p&gt;关于如何使用我就不在赘述了，大家可以参考上面博客进行查看，作者代码在github上也有给出。查看作者代码发现作者应该用的Arduino mega板，电机控制器是L298N模块，我使用的是Arduino Uno板作为测试，电机控制器也选用的L298N，所以更改代码如下：&lt;/p&gt;

&lt;p&gt;将&lt;a href=&quot;https://github.com/Sunlcy/ros_arduino_bridge/tree/indigo-devel-saturnbot-pid-tuning/ros_arduino_firmware/src/libraries/ROSArduinoBridge/encoder_driver.h&quot;&gt;ros_arduino_bridge/ros_arduino_firmware/src/libraries/ROSArduinoBridge/encoder_driver.h&lt;/a&gt;的内容：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#ifdef ARDUINO_MY_COUNTER  
  #define LEFT_ENC_A 2  
  #define LEFT_ENC_B 22  
  #define RIGHT_ENC_A 21  
  #define RIGHT_ENC_B 24  
  void initEncoders();  
  void leftEncoderEvent();  
  void rightEncoderEvent();  
#endif 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;修改为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #ifdef ARDUINO_MY_COUNTER  
      #define LEFT_ENC_A 2  
      #define LEFT_ENC_B 4  
      #define RIGHT_ENC_A 3  
      #define RIGHT_ENC_B 11  
      void initEncoders();  
      void leftEncoderEvent();  
      void rightEncoderEvent();  
    #endif  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;关于这点需要注意，由于Arduino Uno只有两个中断，所以只能将两个中断分开给左编码器和右编码器，即Uno两个中断对应硬件分别为2和3，其中引脚2对应中断号为0，引脚3对应中断号为1，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ros-arduino-bridge-usage/arduino_pin.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;修改完成后，还需修改&lt;a href=&quot;https://github.com/Sunlcy/ros_arduino_bridge/tree/indigo-devel-saturnbot-pid-tuning/ros_arduino_firmware/src/libraries/ROSArduinoBridge/encoder_driver.ino&quot;&gt;ros_arduino_bridge/ros_arduino_firmware/src/libraries/ROSArduinoBridge/encoder_driver.ino&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;将内容&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    void initEncoders(){  
      pinMode(LEFT_ENC_A, INPUT);  
      pinMode(LEFT_ENC_B, INPUT);  
      pinMode(RIGHT_ENC_A, INPUT);  
      pinMode(RIGHT_ENC_B, INPUT);  
      
      attachInterrupt(0, leftEncoderEvent, CHANGE);  
      attachInterrupt(2, rightEncoderEvent, CHANGE);  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;修改为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    void initEncoders(){  
      pinMode(LEFT_ENC_A, INPUT);  
      pinMode(LEFT_ENC_B, INPUT);  
      pinMode(RIGHT_ENC_A, INPUT);  
      pinMode(RIGHT_ENC_B, INPUT);  
      
      attachInterrupt(0, leftEncoderEvent, CHANGE);  
      attachInterrupt(1, rightEncoderEvent, CHANGE);  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意变化，mega有四个中断，而Uno只有两个，所以需要修改为中断0、中断1。不然造成的结果是有一个电机编码器无数据，一直为0。&lt;/p&gt;

&lt;p&gt;同样的，如果引脚类型不对应也会造成错误，如右电机，我将编码器A接上引脚3，编码器B接上引脚12，造成结果是右编码器数据一直在累加，即使电机没有转动，这是由于引脚3作为中断，类型为PWN引脚，而引脚12则为数字引脚，所以需要将编码器B接上引脚11，这是由于引脚11也为PWM类型，这样就不会造成错误。&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Nov 2017 09:04:46 -0800</pubDate>
        <link>http://localhost:4000/2017/11/25/ros-arduino-bridge-usage/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/25/ros-arduino-bridge-usage/</guid>
        
        <category>ROS1</category>
        
        <category>ros_arduino_bridge</category>
        
        
      </item>
    
      <item>
        <title>【ROS总结】Turtlebot ROS 开机自启动设置(2)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/76549144&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;之前写过一篇&lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/52437927&quot;&gt;Turtlebot下的开机自启动设置&lt;/a&gt;，这几天由于项目原因重新整理下，虽然已经有过先例，但是还是碰到了不少错误(keng)，前一篇写的是rc.local方式写入制成自启动脚本，现在换一种方式，改用启动内置控制台终端tty形式作为自启动设置，适用于桌面。&lt;/p&gt;

&lt;p&gt;开机启动方式很多，不唯一，我所知道的是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;rc.local开启启动&lt;/li&gt;
  &lt;li&gt;linux内置服务启动，包括上一篇的ROS的upstart包。&lt;/li&gt;
  &lt;li&gt;内置控制台终端启动tty&lt;/li&gt;
  &lt;li&gt;开机界面后启动终端，例如Startup Application.等等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面以项目为例讲述开机启动，rc.local就不在赘述了，目前两个功能进行实现，一种是开启自启动地图创建程序，另一种是开机自启动跟随脚本，两个脚本还是和之前一样，所有的节点全部都在一个脚本中。&lt;/p&gt;

&lt;p&gt;原本觉得很容易，结果很悲剧的我想当然了，尤其是地图创建程序，涉及到两台电脑通信，如果把两个脚本（minimal和gmapping_demo）合并的话，就可以发现，程序挂起成功，在进程中可以看到，但是，没法用另外一台电脑查看，也就是说，另一台电脑和turtlebot上电脑没有master通信，不用怀疑，ROS的系统变量是正确的，并且两台电脑是同一网段，就是没有办法用另一台电脑使用rosnode list来查看turtlebot上电脑的节点。如果有知道原因的还请告知，个人理解应该是gmapping的代码导致master外部通信阻塞缘故。&lt;/p&gt;

&lt;p&gt;好，言归正转，地图创建自启动程序分开运行，原因如上，也就是说分别开两个终端运行minimal和gmapping。如下&lt;/p&gt;

&lt;h2 id=&quot;内置控制台终端tty自启动&quot;&gt;内置控制台终端tty自启动&lt;/h2&gt;

&lt;p&gt;这个方式只对gmapping使用就可以了，其他都是正常的，因为没有把脚本分开，所以使用两个tty控制台。&lt;/p&gt;

&lt;p&gt;首先打开终端，输入如下命令：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$  sudo vi /etc/init/tty1.config 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;整个文件如下，修改部分请对照好。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    # tty1 - getty  
    #  
    # This service maintains a getty on tty1 from the point the system is  
    # started until it is shut down again.  
      
    start on stopped rc RUNLEVEL=[2345] and (  
                not-container or  
                container CONTAINER=lxc or  
                container CONTAINER=lxc-libvirt)  
      
    stop on runlevel [!2345]  
      
    respawn  
    exec /sbin/getty -8 38400 tty1  
    exec /sbin/mingetty --autologin ubuntu tty1  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;同样的保存退出后，修改另一个终端，输入如下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$  sudo vi /etc/init/tty2.config 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# tty2 - getty  
#  
# This service maintains a getty on tty2 from the point the system is  
# started until it is shut down again.  
  
start on runlevel [23] and (  
            not-container or  
            container CONTAINER=lxc or  
            container CONTAINER=lxc-libvirt)  
  
stop on runlevel [!23]  
  
respawn  
exec /sbin/getty -8 38400 tty2  
exec /sbin/mingetty --autologin ubuntu tty2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;随后修改登陆命令，改成不需要密码登陆，输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$  sudo vi /etc/sudoers 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;全部文本如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#  
# This file MUST be edited with the 'visudo' command as root.  
#  
# Please consider adding local content in /etc/sudoers.d/ instead of  
# directly modifying this file.  
#  
# See the man page for details on how to write a sudoers file.  
#  
Defaults        env_reset  
Defaults        mail_badpass  
Defaults        secure_path=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin&quot;  
  
# Host alias specification  
  
# User alias specification  
  
# Cmnd alias specification  
  
# User privilege specification  
root    ALL=(ALL:ALL) ALL  
  
# Members of the admin group may gain root privileges  
%admin ALL=(ALL) ALL  
  
# Allow members of group sudo to execute any command  
%sudo   ALL=(ALL:ALL) ALL  
  
# See sudoers(5) for more information on &quot;#include&quot; directives:  
  
#includedir /etc/sudoers.d  
  
ubuntu ALL=NOPASSWD:ALL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后修改~/.bashrc文件，在最后添加：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$  gedit ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;添加：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ##auto start  
        Terminal=`tty`  
        case $Terminal in  
            &quot;/dev/tty1&quot;) roslaunch turtlebot_bringup minimal.launch;;  #在tty1 启动minimal  
            &quot;/dev/tty2&quot;) sleep 10;roslaunch turtlebot_navigation gmapping_demo.launch;;  #等待10秒后，在tty2启动地图创建  
        esac  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;

&lt;p&gt;在开始测试之前，首先确保你的bashrc文件中，修改正确了ROS_HOSTNAME和ROS_IP以及ROS_MASTER_URI的值，并且和另一台测试电脑在同一网段。&lt;/p&gt;

&lt;p&gt;turtlebot电脑运行成功提示，假设当前ip为192.168.0.100，另一台测试电脑ip为192.168.0.101，配置如下：&lt;/p&gt;

&lt;p&gt;turtlebot电脑的.bashrc中，应该有&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    export ROS_HOSTNAME=192.168.0.100  
    export ROS_IP=192.168.0.100  
    export ROS_MASTER_URI=http://192.168.0.100:11311
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;测试电脑.bashrc，也应该有&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ROS_HOSTNAME=192.168.0.101  
export ROS_IP=192.168.0.101  
export ROS_MASTER_URI=http://192.168.0.100:11311 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;重新启动turtlebot电脑，等待完成后，使用另一台电脑测试，运行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch turtlebot_rviz_launchers view_navigation.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就可以在viz中看到当前地图创建情况，控制运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    roslaunch turtlebot_teleop keyboard_teleop.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;地图创建自启动完成。&lt;/p&gt;

&lt;h2 id=&quot;其他方式自启动&quot;&gt;其他方式自启动&lt;/h2&gt;

&lt;h3 id=&quot;startup-applications&quot;&gt;Startup Applications&lt;/h3&gt;
&lt;p&gt;只讲述linux应用设置，关于ROS包，教程太多就不说了，最简单的自启动方式就是在桌面上，按下“开始”键位，在弹出的搜索框中输入“Startup Applications”，应用弹出后，选择Add，然后在command行中输入：/usr/bin/gnome-terminal -x /home/ubuntu/aotu_runing/minimal_follower.sh即可。&lt;/p&gt;

&lt;p&gt;minimal_follower.sh内容如下:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#! /bin/bash&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-z&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$DBUS_SESSION_BUS_ADDRESS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
      &lt;span class=&quot;c&quot;&gt;## if not found, launch a new one&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;eval&lt;/span&gt; &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;dbus-launch &lt;span class=&quot;nt&quot;&gt;--sh-syntax&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--exit-with-session&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D-Bus per-session daemon address is: &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$DBUS_SESSION_BUS_ADDRESS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fi
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; +%Y%m%d-%H:%M:%S&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$d&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]:source opt &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /home/&lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;/aotu_runing/print_log.txt

&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /opt/ros/indigo/setup.bash
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$d&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]:source bashrc &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; /home/&lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;/aotu_runing/print_log.txt

&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /home/ubuntu/.bashrc
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$d&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]:source catkin_ws &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; /home/&lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;/aotu_runing/print_log.txt

&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /home/&lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;/catkin_ws/devel/setup.bash

&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TURTLEBOT_BASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;kobuki
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TURTLEBOT_3D_SENSOR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;astra
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ROS_HOSTNAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;localhost
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ROS_MASTER_URI&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://localhost:1311
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$d&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]:source catkin_ws again &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; /home/&lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;/aotu_runing/print_log.txt

&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /home/&lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;/catkin_ws/devel/setup.bash
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$d&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]:minimal runing &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /home/&lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;/aotu_runing/print_log.txt
roslaunch roch_bringup minimal_follower.launch  &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;  /home/&lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;/aotu_runing/print_log.txt
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$d&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]:minimal runing successfully. &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; /home/&lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;/aotu_runing/print_log.txt

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最终这个脚本启动的是turtlebot_bringup下的 minimal_follower.launch，minimal_follower.launch内容如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;launch&amp;gt;
  &amp;lt;!-- TURTLEBOT Configure --&amp;gt;
  &amp;lt;arg name=&quot;base&quot;                      default=&quot;$(env TURTLEBOT_BASE)&quot;                              doc=&quot;mobile base type [TURTLEBOT]&quot;/&amp;gt;
  &amp;lt;arg name=&quot;stacks&quot;                    default=&quot;$(env TURTLEBOT_STACKS)&quot;                    doc=&quot;stack type displayed in visualisation/simulation [standard]&quot;/&amp;gt;
  &amp;lt;arg name=&quot;3d_sensor&quot;                 default=&quot;$(env TURTLEBOT_3D_SENSOR)&quot;                 doc=&quot;3d sensor types [kinect, asus_xtion_pro, r200]&quot;/&amp;gt;
  &amp;lt;arg name=&quot;serialport&quot;                default=&quot;$(env TURTLEBOT_SERIAL_PORT)&quot;               doc=&quot;used by create to configure the port it is connected on [/dev/ttyUSB0, /dev/ttyS0]&quot;/&amp;gt;
  &amp;lt;arg name=&quot;simulation&quot;        default=&quot;$(env TURTLEBOT_SIMULATION)&quot;                doc=&quot;set flags to indicate this turtle is run in simulation mode.&quot;/&amp;gt;
  &amp;lt;arg name=&quot;robot_name&quot;        default=&quot;$(env TURTLEBOT_NAME)&quot;                      doc=&quot;used as a unique identifier and occasionally to preconfigure root namespaces, gateway/zeroconf ids etc.&quot;/&amp;gt;
  &amp;lt;arg name=&quot;robot_type&quot;        default=&quot;$(env TURTLEBOT_TYPE)&quot;                      doc=&quot;just in case you are considering a 'variant' and want to make use of this.&quot;/&amp;gt;


  &amp;lt;param name =&quot;/use_sim_time&quot; value=&quot;$(arg simulation)&quot;/&amp;gt;

  &amp;lt;!-- Load robot model --&amp;gt;
  &amp;lt;include file=&quot;$(find turtlebot_bringup)/launch/includes/robot.launch.xml&quot;&amp;gt;
    &amp;lt;arg name=&quot;base&quot; value=&quot;$(arg base)&quot; /&amp;gt;
    &amp;lt;arg name=&quot;stacks&quot; value=&quot;$(arg stacks)&quot; /&amp;gt;
    &amp;lt;arg name=&quot;3d_sensor&quot; value=&quot;$(arg 3d_sensor)&quot; /&amp;gt;
  &amp;lt;/include&amp;gt;

  &amp;lt;!-- Load robot base--&amp;gt;
  &amp;lt;include file=&quot;$(find turtlebot_bringup)/launch/includes/mobile_base.launch.xml&quot;&amp;gt;
    &amp;lt;arg name=&quot;base&quot; value=&quot;$(arg base)&quot; /&amp;gt;
    &amp;lt;arg name=&quot;serialport&quot; value=&quot;$(arg serialport)&quot; /&amp;gt;
  &amp;lt;/include&amp;gt;

 &amp;lt;group unless=&quot;$(arg simulation)&quot;&amp;gt; &amp;lt;!-- Real robot --&amp;gt;
    &amp;lt;include file=&quot;$(find turtlebot_follower)/launch/includes/velocity_smoother.launch.xml&quot;&amp;gt;
      &amp;lt;arg name=&quot;nodelet_manager&quot;  value=&quot;/mobile_base_nodelet_manager&quot;/&amp;gt;
      &amp;lt;arg name=&quot;navigation_topic&quot; value=&quot;twist_mux/input/navi&quot;/&amp;gt;
    &amp;lt;/include&amp;gt;

    &amp;lt;include file=&quot;$(find turtlebot_bringup)/launch/sensor.launch&quot;&amp;gt;
      &amp;lt;arg name=&quot;rgb_processing&quot;                  value=&quot;true&quot;/&amp;gt;  &amp;lt;!-- only required if we use android client --&amp;gt;
      &amp;lt;arg name=&quot;depth_processing&quot;                value=&quot;true&quot;/&amp;gt;
      &amp;lt;arg name=&quot;depth_registered_processing&quot;     value=&quot;false&quot;/&amp;gt;
      &amp;lt;arg name=&quot;depth_registration&quot;              value=&quot;false&quot;/&amp;gt;
      &amp;lt;arg name=&quot;disparity_processing&quot;            value=&quot;false&quot;/&amp;gt;
      &amp;lt;arg name=&quot;disparity_registered_processing&quot; value=&quot;false&quot;/&amp;gt;
    &amp;lt;/include&amp;gt;
  &amp;lt;/group&amp;gt;
  &amp;lt;group if=&quot;$(arg simulation)&quot;&amp;gt;
    &amp;lt;!-- Load nodelet manager for compatibility --&amp;gt;
    &amp;lt;node pkg=&quot;nodelet&quot; type=&quot;nodelet&quot; ns=&quot;camera&quot; name=&quot;camera_nodelet_manager&quot; args=&quot;manager&quot;/&amp;gt;

    &amp;lt;include file=&quot;$(find turtlebot_follower)/launch/includes/velocity_smoother.launch.xml&quot;&amp;gt;
      &amp;lt;arg name=&quot;nodelet_manager&quot;  value=&quot;camera/camera_nodelet_manager&quot;/&amp;gt;
      &amp;lt;arg name=&quot;navigation_topic&quot; value=&quot;/twist/input/navi&quot;/&amp;gt;
    &amp;lt;/include&amp;gt;
  &amp;lt;/group&amp;gt;

  &amp;lt;param name=&quot;camera/rgb/image_color/compressed/jpeg_quality&quot; value=&quot;22&quot;/&amp;gt;

  &amp;lt;!-- Make a slower camera feed available; only required if we use android client --&amp;gt;
  &amp;lt;node pkg=&quot;topic_tools&quot; type=&quot;throttle&quot; name=&quot;camera_throttle&quot;
        args=&quot;messages camera/rgb/image_color/compressed 5&quot;/&amp;gt;


  &amp;lt;!--  Real robot: Load turtlebot follower into the  sensors nodelet manager to avoid pointcloud serializing --&amp;gt;
  &amp;lt;!--  Simulation: Load turtlebot follower into nodelet manager for compatibility --&amp;gt;
  &amp;lt;node pkg=&quot;nodelet&quot; type=&quot;nodelet&quot; name=&quot;turtlebot_follower&quot;
        args=&quot;load turtlebot_follower/TurtlebotFollower camera/camera_nodelet_manager&quot;&amp;gt;
    &amp;lt;remap from=&quot;turtlebot_follower/cmd_vel&quot; to=&quot;follower_velocity_smoother/raw_cmd_vel&quot;/&amp;gt;
    &amp;lt;remap from=&quot;depth/points&quot; to=&quot;camera/depth/points&quot;/&amp;gt;
    &amp;lt;remap from=&quot;depth/image_rect&quot; to=&quot;/camera/depth/image_rect&quot;/&amp;gt;
    &amp;lt;param name=&quot;enabled&quot; value=&quot;true&quot; /&amp;gt;
    &amp;lt;param name=&quot;x_scale&quot; value=&quot;7.0&quot; /&amp;gt;
    &amp;lt;param name=&quot;z_scale&quot; value=&quot;2.0&quot; /&amp;gt;
    &amp;lt;param name=&quot;min_x&quot; value=&quot;-0.35&quot; /&amp;gt;
    &amp;lt;param name=&quot;max_x&quot; value=&quot;0.35&quot; /&amp;gt;
    &amp;lt;param name=&quot;min_y&quot; value=&quot;0.1&quot; /&amp;gt;
    &amp;lt;param name=&quot;max_y&quot; value=&quot;0.5&quot; /&amp;gt;
    &amp;lt;param name=&quot;max_z&quot; value=&quot;1.2&quot; /&amp;gt;
    &amp;lt;param name=&quot;goal_z&quot; value=&quot;0.6&quot; /&amp;gt;
  &amp;lt;/node&amp;gt;
  &amp;lt;!-- Launch the script which will toggle turtlebot following on and off based on a joystick button. default: on --&amp;gt;
  &amp;lt;node name=&quot;switch&quot; pkg=&quot;turtlebot_follower&quot; type=&quot;switch.py&quot;/&amp;gt;
&amp;lt;/launch&amp;gt;
                                                                                          
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用桌面程序弊端在于修改的话需要重新连接显示屏，比较麻烦，不过不长改。&lt;/p&gt;

&lt;p&gt;注意：$USER千万不要用在/etc/rc.local下，否则会造成rc.local自启动不成功，没有反应，这一点坑了我很长时间。&lt;/p&gt;

&lt;p&gt;如果启动后，无法跟随，说明astra没有启动成功，可以在/var/log/apport.log中看到输出消息，解决办法就是在脚本中添加：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if test -z &quot;$DBUS_SESSION_BUS_ADDRESS&quot; ; then  
          ## if not found, launch a new one  
          eval `dbus-launch --sh-syntax --exit-with-session`  
          echo &quot;D-Bus per-session daemon address is: $DBUS_SESSION_BUS_ADDRESS&quot;  
    fi  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;就可以。&lt;/p&gt;

&lt;h3 id=&quot;robot_upstart-网络&quot;&gt;robot_upstart 网络&lt;/h3&gt;
&lt;h4 id=&quot;配置&quot;&gt;配置&lt;/h4&gt;
&lt;p&gt;今天使用前几个方式在笔记本上进行自启动不成功，原因应该在于网络，节点/话题什么都有，但是无法使用rosnode list，因此，使用了robot_upstart来尝试，首先安装robot_upstart包，安装步骤比较简单：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install ros-indigo-robot-upstart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装完成后，大家可以查看&lt;a href=&quot;http://docs.ros.org/jade/api/robot_upstart/html/&quot;&gt;使用文档&lt;/a&gt;来进行使用，方式也比较简单，不过是单一launch启动，由于clearpath的机器人譬如husky只提供了底盘启动的缘故，不过大家可以将多个launch合并为一个来进行启动，启动方式也比较简单，首先，安装需要自启动的launch文件，使用方式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rosrun robot_upstart install myrobot_bringup/launch/base.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中myrobot_bringup是要启动launch文件所在的包，base.launch是要启动的launch文件，只需要提供包到launch文件路径即可。需要注意的是，运行这个命令需要在sudo root权限下，这个步骤将写到系统中。&lt;/p&gt;

&lt;p&gt;安装launch文件完成后，将提示有很多文件被放到了系统中，如下输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Preparing to install files to the following paths:  
      /etc/init/turtlebot.conf  
      /etc/ros/indigo/turtlebot.d/.installed_files  
      /etc/ros/indigo/turtlebot.d/minimal.launch  
      /usr/sbin/turtlebot-start  
      /usr/sbin/turtlebot-stop  
    Now calling: /usr/bin/sudo /opt/ros/indigo/lib/robot_upstart/mutate_files  
    Filesystem operation succeeded. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在启动服务的话，只是单机模式，即ROS_HOSTNAME/ROS_IP/ROS_MASTER_URI都是localhost，如果想要另外一个同一网段的计算机查看当前计算机的node/topic时，就需要对脚本进行修改，重要的脚本为  /usr/sbin/turtlebot-start，将该脚本中的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    28  export ROS_HOSTNAME=$(hostname)  
      
    30  export ROS_MASTER_URI=http://127.0.0.1:11311  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;修改为当前电脑局域网内的IP，比如我的为192.168.0.106，最好将上面的注释掉，重新书写一遍：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;28  export ROS_HOSTNAME=192.168.0.106  
  
30  export ROS_MASTER_URI=http://192.168.0.106:11311 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在运行服务，运行操作共有如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo service myrobot start  #启动脚本服务  
$ sudo service myrobot stop  #停止脚本服务  
$ sudo service myrobot restart  #重启脚本服务 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中myrobot为安装launch文件中提示的，比如我的为turtlebot，查看/usr/sbin/turtlebot-start名字可以知道。启动完成后，在本地运行终端：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rostopic list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将会有输出，也可以在同一网段内的电脑上，配置好网络后，运行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rostopic list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也可以得到输出。服务输出日志文件为/var/log/upstart/myrobot.log，其中myrobot在我的电脑上为turtlebot.log。如果运行服务后没有输出，可以查看这个文件进行调试。&lt;/p&gt;

&lt;h4 id=&quot;卸载&quot;&gt;卸载&lt;/h4&gt;

&lt;p&gt;卸载命令如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rosrun robot_upstart uninstall [-h] [--rosdistro DISTRO] JOBNAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中，JOBNAME是要卸载的脚本，比如我的是turtlebot，DISTRO为指定ROS版本，存在多个脚本时需要用到，比如：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rosrun robot_upstart uninstall turtlebot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Tue, 01 Aug 2017 12:31:00 -0700</pubDate>
        <link>http://localhost:4000/2017/08/01/turtlebot-startup-2/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/01/turtlebot-startup-2/</guid>
        
        <category>ROS1</category>
        
        <category>Turtlebot2</category>
        
        <category>Startup</category>
        
        
      </item>
    
      <item>
        <title>【ROS总结】ROS故障排除</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/72852251&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在ROS学习与开发中，难免遇到各种各样的问题，除了一些可以解决问题（语法问题）外，其他一些问题有时很难发现并解决，在这里，总结下在开发中遇到的各种问题，不定期更新中。。。&lt;/p&gt;

&lt;p&gt;为了方便和管理，每一个标题都是一些问题模块，现在有catkin_make编译模块。&lt;/p&gt;

&lt;h2 id=&quot;catkin_make问题&quot;&gt;catkin_make问题&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;问题1&lt;/strong&gt;：在使用catkin_make过程中，明明有需要编译的包，但是系统提示找不到该路径，具体输出如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Traceback (most recent call last):
  File &quot;/opt/ros/indigo/share/genjava/cmake/../../../lib/genjava/genjava_gradle_project.py&quot;, line 14, in &amp;lt;module&amp;gt;
    genjava.main(sys.argv)
  File &quot;/opt/ros/indigo/lib/python2.7/dist-packages/genjava/genjava_main.py&quot;, line 82, in main
    gradle_project.create(args.package, args.output_dir)
  File &quot;/opt/ros/indigo/lib/python2.7/dist-packages/genjava/gradle_project.py&quot;, line 152, in create
    raise IOError(&quot;could not find %s on the ros package path&quot; % msg_pkg_name)
IOError: could not find turtlebot2i_marker_manipulation on the ros package path
make[2]: *** [turtlebot2i_marker_manipulation/java/turtlebot2i_marker_manipulation/build.gradle] Error 1
make[1]: *** [turtlebot2i_marker_manipulation/CMakeFiles/turtlebot2i_marker_manipulation_generate_messages_java_gradle.dir/all] Error 2
make[1]: *** Waiting for unfinished jobs....
Traceback (most recent call last):
  File &quot;/opt/ros/indigo/share/genjava/cmake/../../../lib/genjava/genjava_gradle_project.py&quot;, line 14, in &amp;lt;module&amp;gt;
    genjava.main(sys.argv)
  File &quot;/opt/ros/indigo/lib/python2.7/dist-packages/genjava/genjava_main.py&quot;, line 82, in main
    gradle_project.create(args.package, args.output_dir)
  File &quot;/opt/ros/indigo/lib/python2.7/dist-packages/genjava/gradle_project.py&quot;, line 152, in create
    raise IOError(&quot;could not find %s on the ros package path&quot; % msg_pkg_name)
IOError: could not find turtlebot2i_marker_manipulation on the ros package path

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;IOError: &lt;span style=&quot;color:red;&quot;&gt; could not find &lt;/span&gt; turtlebot2i_marker_manipulation &lt;span style=&quot;color:red;&quot;&gt;on the ros package path. &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;
下载genjava就可以正常编译。原因不明。命令如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get remove ros-indigo-genjava 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;moveit-问题&quot;&gt;Moveit! 问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;问题1：&lt;/strong&gt; 当运行&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch moveit_setup_assistant setup_assistant.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;选择模型加载时，会突然系统崩溃。提示如下信息：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[rospack] Error: no package given
[librospack]: error while executing command
[ INFO] [1496720764.674712823]: Running 'rosrun xacro xacro.py /home/carl/Desktop/Project/turtlebot2i/src/turtlebot2i/turtlebot2i_description/robots/kobuki_interbotix_zr300.urdf.xacro'...
[ INFO] [1496720765.546447152]: Loaded turtlebot robot model.
[ INFO] [1496720765.546519891]: Setting Param Server with Robot Description
[ INFO] [1496720765.555161202]: Robot semantic model successfully loaded.
[ INFO] [1496720765.555195476]: Setting Param Server with Robot Semantic Description
[ INFO] [1496720765.570819680]: Loading robot model 'turtlebot'...
[ INFO] [1496720765.570888991]: No root/virtual joint specified in SRDF. Assuming fixed joint
================================================================================REQUIRED process [moveit_setup_assistant-1] has died!
process has died [pid 8123, exit code -11, cmd /opt/ros/indigo/lib/moveit_setup_assistant/moveit_setup_assistant __name:=moveit_setup_assistant __log:=/home/carl/.ros/log/689c9c26-4a64-11e7-8883-d85de2b5c407/moveit_setup_assistant-1.log].
log file: /home/carl/.ros/log/689c9c26-4a64-11e7-8883-d85de2b5c407/moveit_setup_assistant-1*.log
Initiating shutdown!
================================================================================
[moveit_setup_assistant-1] killing on exit
shutting down processing monitor...
... shutting down processing monitor complete
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;单独加载模型没问题.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用moveit_setup加载其他模型有的没问题（例如，Turtlebot）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;只是使用有些模型会出现突然崩溃的情况。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方式1：&lt;/strong&gt;检查模型中模型的&lt;collision&gt;属性，里面的&lt;geometry&gt;是否加载的是.dae或.stl文件，如果有，将.dae或.stl替换成urdf本身自有的属性，例如&lt;cylinder&gt;，&lt;box&gt;等。
举例：将&lt;/box&gt;&lt;/cylinder&gt;&lt;/geometry&gt;&lt;/collision&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &amp;lt;collision&amp;gt;
        &amp;lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0 0 0&quot;/&amp;gt;
        &amp;lt;geometry&amp;gt;
          &amp;lt;mesh filename=&quot;package://turtlebot2i_description/meshes/sensors/sr300.stl&quot; scale=&quot;2.0 2.0 2.0&quot; /&amp;gt;
        &amp;lt;/geometry&amp;gt;
      &amp;lt;/collision&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;替换成&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &amp;lt;collision&amp;gt;
        &amp;lt;origin xyz=&quot;0 0 0&quot; rpy=&quot;0 0 0&quot;/&amp;gt;
        &amp;lt;geometry&amp;gt;
          &amp;lt;cylinder length=&quot;0.006&quot; radius=&quot;0.170&quot;/&amp;gt;
        &amp;lt;/geometry&amp;gt;
      &amp;lt;/collision&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;方式2：&lt;/strong&gt;测试了下moveit_setup_assistant，发现模型加载mesh时，会出错，方式1是将现有属性替换，另外一种方式是改变自己制作的dae或stl文件名，不清楚什么原因，moveit_setup_assistant加载dae或stl时，模型名必须为小写，如果有大写出现就会报错，例如将Test_Finger.dae修改为test_finger.dae就不会造成崩溃。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方式3：&lt;/strong&gt;如果是在加载别人做的dae或stl文件时，需要将dae或stl文件重写，我使用的是blender，将stl重新导出stl就不会造成崩溃。其他3D建模也可以尝试下，3D Max，solidworks，inventor等等。&lt;/p&gt;

&lt;p&gt;其他解决方案如果有请告知。&lt;/p&gt;

&lt;h2 id=&quot;ros_control--gazebo问题&quot;&gt;ROS_Control + Gazebo问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;问题1：&lt;/strong&gt;使用ros_control为模型添加Gazebo接口时，模型单独显示没有问题，在Gazebo中添加会错误，从而导致加载不了ros_control接口，报错如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ERROR] [1497406213.064550049, 0.172000000]: No valid hardware interface element found in joint 'wheel_joint_fl'.
[ERROR] [1497406213.064681421, 0.172000000]: Failed to load joints for transmission 'wheel_trans_fl'.
[ERROR] [1497406213.064711210, 0.172000000]: No valid hardware interface element found in joint 'caster_joint_fl'.
[ERROR] [1497406213.064765673, 0.172000000]: Failed to load joints for transmission 'caster_trans_fl'.
[ERROR] [1497406213.064781965, 0.172000000]: No valid hardware interface element found in joint 'wheel_joint_fr'.
[ERROR] [1497406213.064794358, 0.172000000]: Failed to load joints for transmission 'wheel_trans_fr'.
[ERROR] [1497406213.064806668, 0.172000000]: No valid hardware interface element found in joint 'caster_joint_fr'.
[ERROR] [1497406213.064815775, 0.172000000]: Failed to load joints for transmission 'caster_trans_fr'.
[ERROR] [1497406213.064826099, 0.172000000]: No valid hardware interface element found in joint 'wheel_joint_bl'.
[ERROR] [1497406213.064837826, 0.172000000]: Failed to load joints for transmission 'wheel_trans_bl'.
[ERROR] [1497406213.064850074, 0.172000000]: No valid hardware interface element found in joint 'caster_joint_bl'.
[ERROR] [1497406213.064861368, 0.172000000]: Failed to load joints for transmission 'caster_trans_bl'.
[ERROR] [1497406213.064874445, 0.172000000]: No valid hardware interface element found in joint 'wheel_joint_br'.
[ERROR] [1497406213.064884656, 0.172000000]: Failed to load joints for transmission 'wheel_trans_br'.
[ERROR] [1497406213.064893785, 0.172000000]: No valid hardware interface element found in joint 'caster_joint_br'.
[ERROR] [1497406213.064902338, 0.172000000]: Failed to load joints for transmission 'caster_trans_br'.
[ERROR] [1497406213.064913362, 0.172000000]: No valid hardware interface element found in joint 'arm_joint_1'.
[ERROR] [1497406213.064923217, 0.172000000]: Failed to load joints for transmission 'arm_trans_1'.
[ERROR] [1497406213.064932655, 0.172000000]: No valid hardware interface element found in joint 'arm_joint_2'.
[ERROR] [1497406213.064942810, 0.172000000]: Failed to load joints for transmission 'arm_trans_2'.
[ERROR] [1497406213.064956180, 0.172000000]: No valid hardware interface element found in joint 'arm_joint_3'.
[ERROR] [1497406213.064965970, 0.172000000]: Failed to load joints for transmission 'arm_trans_3'.
[ERROR] [1497406213.064976051, 0.172000000]: No valid hardware interface element found in joint 'arm_joint_4'.
[ERROR] [1497406213.064985608, 0.172000000]: Failed to load joints for transmission 'arm_trans_4'.
[ERROR] [1497406213.064995977, 0.172000000]: No valid hardware interface element found in joint 'arm_joint_5'.
[ERROR] [1497406213.065005730, 0.172000000]: Failed to load joints for transmission 'arm_trans_5'.
[ERROR] [1497406213.065017694, 0.172000000]: No valid hardware interface element found in joint 'gripper_finger_joint_l'.
[ERROR] [1497406213.065026496, 0.172000000]: Failed to load joints for transmission 'gripper_finger_l_trans'.
[ERROR] [1497406213.065036557, 0.172000000]: No valid hardware interface element found in joint 'gripper_finger_joint_r'.
[ERROR] [1497406213.065046327, 0.172000000]: Failed to load joints for transmission 'gripper_finger_r_trans'.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt;该问题原因是ros_control接口更新，有的旧的会不兼容，通过给&lt;joint&gt;选项添加&lt;hardwareinterface&gt;标签，这个错误会消失，比如，在rrbot.xacro文件中，改变：&lt;/hardwareinterface&gt;&lt;/joint&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;joint name=&quot;joint1&quot;/&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;transmission name=&quot;tran1&quot;&amp;gt;
  &amp;lt;type&amp;gt;transmission_interface/SimpleTransmission&amp;lt;/type&amp;gt;
  &amp;lt;joint name=&quot;joint1&quot;&amp;gt;
    &amp;lt;hardwareInterface&amp;gt;EffortJointInterface&amp;lt;/hardwareInterface&amp;gt;
  &amp;lt;/joint&amp;gt;
&amp;lt;/transmission&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Jun 2017 08:17:12 -0700</pubDate>
        <link>http://localhost:4000/2017/06/03/ros-troubleshooting/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/03/ros-troubleshooting/</guid>
        
        <category>ROS1</category>
        
        <category>Troubleshooting</category>
        
        
      </item>
    
      <item>
        <title>【ROS总结】ROS下的百度语音识别应用</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/55001444&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;今天闲来无事查看下语音识别在ROS中的应用，之前在ROS中玩过一段时间的Pocket Sphinx，关于Pocket Sphinx的学习过程以后会介绍，或者可以去网上搜索一些教程，都是比较不错的。现在讲述下在ROS中百度语音的使用情况，由于百度语音的作者写了一些文章在Github上，但是步骤不是很清楚，在此记录一下防止以后忘记，也和大家分享下，避免出现一些失误而导致半途而废。&lt;/p&gt;

&lt;p&gt;需求:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;软件&lt;/th&gt;
      &lt;th&gt;版本&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;操作系统&lt;/td&gt;
      &lt;td&gt;Ubuntu 14.04.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ROS版本&lt;/td&gt;
      &lt;td&gt;Indigo&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;ros语音识别介绍&quot;&gt;ROS语音识别介绍&lt;/h2&gt;
&lt;p&gt;关于一些在ROS中如何使用语音识别库，大家可以自行搜索下，基本上都是在ROS官网上的一些资料，目前官网上的&lt;a href=&quot;http://wiki.ros.org/Sensors&quot;&gt;语音识别库&lt;/a&gt;一共有四个，分别为&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/baidu_speech&quot;&gt;baidu_speech&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/hark&quot;&gt;hark&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/pocketsphinx&quot;&gt;pocketsphinx&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/rospeex&quot;&gt;rospeex&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前讲述的是百度的语音识别，目前百度语音已经支持ROS，大家可以学习下。以后会介绍其他三个语音库。&lt;/p&gt;

&lt;h3 id=&quot;百度语音识别在ros中的应用&quot;&gt;百度语音识别在ROS中的应用&lt;/h3&gt;
&lt;p&gt;关于如何在ROS中使用百度语音识别呢，作者也已经在wiki上介绍了，大家可以先查看下，网址是：http://wiki.ros.org/baidu_speech&lt;/p&gt;

&lt;p&gt;不过作者貌似没有提供在线安装，也就是apt-get来安装百度语音包，不过不妨碍今天的教程，安装百度语音包的过程如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在Github上下载百度语音包&lt;/li&gt;
  &lt;li&gt;安装百度语音包的需求包&lt;/li&gt;
  &lt;li&gt;运行并测试百度语音包中的说话者（simple_speaker.launch）和语音识别（simple_voice.launch）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面根据步骤来进行操作&lt;/p&gt;

&lt;h4 id=&quot;在github上下载百度语音识别包&quot;&gt;在Github上下载百度语音识别包&lt;/h4&gt;
&lt;p&gt;在下载之前，你应该有一个catkin工作空间，我的工作空间名字就是catkin_ws。然后在catkin_ws/src下下载百度语音识别包（simple_voice）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/DinnerHowe/simple_voice.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;下载完成后其实就可以使用，但是会提示错误，例如：No module named pyaudio 或者 Nomodule named vlc&lt;/p&gt;

&lt;p&gt;其实作者也已经说过了，要想使用simple_voice这个包，需要Python库，也就是pyaudio和vlc-python。下面安装需求包。&lt;/p&gt;

&lt;h4 id=&quot;安装百度语音识别包的需求包&quot;&gt;安装百度语音识别包的需求包&lt;/h4&gt;

&lt;p&gt;安装pyaudio其实是比较简单的，直接使用下面的命令就可以安装：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo apt-get install python-pyaudio
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个步骤直接就在线安装了需求包pyaudio。&lt;/p&gt;

&lt;p&gt;安装vlc其实比较坑，或许是我的电脑的问题，没有找到在线安装命令也就是python-vlc这个包，就算安装了vlc所有的包也还是提示No module named vlc。&lt;/p&gt;

&lt;p&gt;不过最终还是解决了，使用如下方式，首先在你的home下，下载vlc的封装库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd  
$ git clone https://github.com/geoffsalmon/vlc-python.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下载完成后，使用如下命令加载vlc模型到Python中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo cp vlc-python/generated/vlc.py /usr/lib/python2.7/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Indigo的Python是2.7版本，大家也可以替换成你当前版本，路径还是/usr/lib。
添加完成需求包后，就可以测试运行百度语音识别包了。&lt;/p&gt;

&lt;h4 id=&quot;运行并测试百度语音包中的说话者simple_speakerlaunch和语音识别simple_voicelaunch&quot;&gt;运行并测试百度语音包中的说话者（simple_speaker.launch）和语音识别（simple_voice.launch）&lt;/h4&gt;

&lt;h5 id=&quot;测试simple_speakerlaunch&quot;&gt;测试simple_speaker.launch&lt;/h5&gt;

&lt;p&gt;首先打开一个终端，输入如下命令来启动simple_speaker.launch&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ roslaunch simple_voice simple_speaker.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;作者在网上说直接运行这个launch就可以听到说话，其实还少一步，需要添加音频文件才可以。作者在语音包中给出了一个“请让一下.mp3”，其他音频文件没有测试，大家可以测试下都支持什么音频文件，在此就不讲述了。&lt;/p&gt;

&lt;p&gt;运行完simple_speaker.launch后，多出了一个/speak_string的话题，该话题就是接收音频文件，需要手动的添加音频文件到simple_speaker节点，其中该launch文件只开启了一个节点就是simple_speaker。&lt;/p&gt;

&lt;p&gt;打开另一个终端，向simple_speaker节点添加音频文件：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ roscd simple_voice/src  
$ rostopic pub /speak_string std_msgs/String -- '请让一下.mp3' 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;测试simple_voicelaunch&quot;&gt;测试simple_voice.launch&lt;/h5&gt;
&lt;p&gt;关于测试simple_voice.launch是容易的，直接一条命令搞定：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ roslaunch simple_voice simple_voice.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后对着电脑说话就可以了，比如:
&lt;img src=&quot;/img/in-post/ros-baidu-speech/baidu_speech_output.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每次只识别一次，识别完成后需要桥下Enter键才能继续识别，当然大家也可以对voice_node.py进行改造，变成实时语音识别。&lt;/p&gt;

</description>
        <pubDate>Sun, 12 Feb 2017 07:01:25 -0800</pubDate>
        <link>http://localhost:4000/2017/02/12/ros-baidu-speech/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/12/ros-baidu-speech/</guid>
        
        <category>ROS1</category>
        
        <category>Baidu Speech</category>
        
        
      </item>
    
      <item>
        <title>【ROS总结】 ROS接口——Odometry</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/52688982&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;版本：Indigo&lt;/p&gt;

&lt;p&gt;这篇文章主要是把平时用到的一些ROS接口梳理一下，避免无法和ros进行对接，首先ROS中相对重要的是里程计（Odometry），里程计的重要性不言而喻，如果没有里程计，不管是建立地图还是导航都不会很好的工作，相应的Odometry更新也有一些节点可以调用，本文主要用到的是&lt;a href=&quot;https://github.com/ros-controls/ros_controllers/blob/indigo-devel/diff_drive_controller/src/odometry.cpp&quot;&gt;ros_controllers中的差分驱动控制器&lt;/a&gt;，&lt;a href=&quot;http://wiki.ros.org/ros_control&quot;&gt;介绍文档如下&lt;/a&gt;，该控制器用处广泛，基本差分驱动都可以用到，从底层得到左右电机编码器数据，通过机器人运动学转换成Odometry消息发送出去，其他节点得到Odometry消息就可以在rviz或者Gazebo中更新机器人位置信息，也可以加上imu数据让机器人更准确。&lt;/p&gt;

&lt;h2 id=&quot;ros_controllers&quot;&gt;ros_controllers&lt;/h2&gt;
&lt;p&gt;安装方法为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install ros-indigo-ros-controllers
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本文并没有直接使用Odometry消息，而是通过ros_controls中的&lt;a href=&quot;http://wiki.ros.org/hardware_interface?distro=indigo&quot;&gt;hardware_interface&lt;/a&gt;来更新Odometry。相应教程说明如下，&lt;a href=&quot;https://github.com/ros-controls/ros_control/wiki/hardware_interface&quot;&gt;链接地址&lt;/a&gt;。直接更新hardware_interface中的joint就可以更新Odometry。在本地声明一个类为myrobot，继承于hardware_interface::RobotHw。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;hardware_interface/joint_command_interface.h&amp;gt;//关节命令接口，用于接收/cmd_vel数据
#include &amp;lt;hardware_interface/joint_state_interface.h&amp;gt;//关节状态接口，用于更新Odometry
#include &amp;lt;hardware_interface/robot_hw.h&amp;gt;

class MyRobot : public hardware_interface::RobotHW
{
public:
  MyRobot() 
 { 
   // connect and register the joint state interface
   hardware_interface::JointStateHandle state_handle_a(&quot;A&quot;, &amp;amp;pos[0], &amp;amp;vel[0], &amp;amp;eff[0]);
   jnt_state_interface.registerHandle(state_handle_a);

   hardware_interface::JointStateHandle state_handle_b(&quot;B&quot;, &amp;amp;pos[1], &amp;amp;vel[1], &amp;amp;eff[1]);
   jnt_state_interface.registerHandle(state_handle_b);

   registerInterface(&amp;amp;jnt_state_interface);

   // connect and register the joint position interface
   hardware_interface::JointHandle pos_handle_a(jnt_state_interface.getHandle(&quot;A&quot;), &amp;amp;cmd[0]);
   jnt_pos_interface.registerHandle(pos_handle_a);

   hardware_interface::JointHandle pos_handle_b(jnt_state_interface.getHandle(&quot;B&quot;), &amp;amp;cmd[1]);
   jnt_pos_interface.registerHandle(pos_handle_b);

   registerInterface(&amp;amp;jnt_pos_interface);
  }

private:
  hardware_interface::JointStateInterface jnt_state_interface;
  hardware_interface::PositionJointInterface jnt_pos_interface;
  double cmd[2];
  double pos[2];
  double vel[2];
  double eff[2];
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中”A”为机器人模型中的关节，一般为wheel_left。同理“B”也是轮子关节，一般为wheel_right。pos为当前机器人的位置，vel为机器人目前速度，eff为初始状态时机器人位置，cmd为接收cmd_vel消息用于控制机器人运动。需要注意的是pos为轮子所走过的弧度，因此上传时需要上传弧度值。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ros-controls/ros_controllers/blob/kinetic-devel/diff_drive_controller/src/odometry.cpp&quot;&gt;Odometry.cpp&lt;/a&gt;文件中更新Odometry的代码为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; bool Odometry::update(double left_pos, double right_pos, const ros::Time &amp;amp;time)
  {
    /// Get current wheel joint positions:
    const double left_wheel_cur_pos  = left_pos  * wheel_radius_;
    const double right_wheel_cur_pos = right_pos * wheel_radius_;

    /// Estimate velocity of wheels using old and current position:
    const double left_wheel_est_vel  = left_wheel_cur_pos  - left_wheel_old_pos_;
    const double right_wheel_est_vel = right_wheel_cur_pos - right_wheel_old_pos_;

    /// Update old position with current:
    left_wheel_old_pos_  = left_wheel_cur_pos;
    right_wheel_old_pos_ = right_wheel_cur_pos;

    /// Compute linear and angular diff:
    const double linear  = (right_wheel_est_vel + left_wheel_est_vel) * 0.5 ;
    const double angular = (right_wheel_est_vel - left_wheel_est_vel) / wheel_separation_;

    /// Integrate odometry:
    integrate_fun_(linear, angular);

    /// We cannot estimate the speed with very small time intervals:
    const double dt = (time - timestamp_).toSec();
    if (dt &amp;lt; 0.0001)
      return false; // Interval too small to integrate with

    timestamp_ = time;

    /// Estimate speeds using a rolling mean to filter them out:
    linear_acc_(linear/dt);
    angular_acc_(angular/dt);

    linear_ = bacc::rolling_mean(linear_acc_);
    angular_ = bacc::rolling_mean(angular_acc_);

    return true;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const double left_wheel_cur_pos  = left_pos  * wheel_radius_;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当前的轮子所走过的弧度*轮子半径，得到当前轮子走过的距离，因此，这就是为什么pos要为弧度值。&lt;/p&gt;

</description>
        <pubDate>Wed, 28 Sep 2016 04:23:57 -0700</pubDate>
        <link>http://localhost:4000/2016/09/28/ros-interface-odometry/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/09/28/ros-interface-odometry/</guid>
        
        <category>ROS1</category>
        
        <category>ros_control</category>
        
        <category>Odometry</category>
        
        
      </item>
    
      <item>
        <title>【ROS总结】Turtlebot ROS 开机自启动设置</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/52437927&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;关于ROS自启动设置，之前查看了很多相关文章，并不是很适用，尤其是开机启动时候加载minimal.launch和amcl.launch的时候，目前开启自启动的ROS包有&lt;a href=&quot;http://docs.ros.org/jade/api/robot_upstart/html/&quot;&gt;upstart&lt;/a&gt;，该包是通过创建一个服务来启动minimal.launch等基本的launch文件，要是启动多个launch文件，可以通过把多个launch文件写入到一个launch中这样的方法来启动。&lt;/p&gt;

&lt;p&gt;还有其他方式是利用Ubuntu自带的开机启动文件来达到多launch文件启动效果，一种是服务，方法和upstart类似，如果想要多launch文件分别启动，例如minimal.launch和amcl.launch两个launch文件，当启动完minimal.launch后，再启动amcl.launch会出现waiting for device…字样，导致的结果就是amcl.launch自动不了，还得重新启动。因此，把多个launch文件写入到一个launch启动就不会提示waiting for device…。&lt;/p&gt;

&lt;h2 id=&quot;rclocal&quot;&gt;rc.local&lt;/h2&gt;

&lt;p&gt;另外一种是在开机启动文件rc.local文件中直接写入ros命令来达到开机启动效果，把minimal和amcl两个launch文件写成一个launch命名为auto_start.launch，然后在rc.laoch中写入如下内容：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;source /opt/ros/indigo/setup.bash
roslaunch /etc/auto_start.launch 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中auto_start.launch文件所在位置并不重要，需要写在exit 0的前面即可，不过这个不能启动用户目录下的配置，如果启动用户目录下的launch文件，需要source ~/.bashrc。&lt;/p&gt;

&lt;p&gt;我用的方法是，把所有需要的配置和launch文件写到了一个脚本中，通过开机启动脚本来达到启动效果，不过经过测试，单独运行两个launch文件还是有错误，即运行完minimal后运行amcl.launch的时候，会卡在waiting for device…。目前解决方法是把minimal和amcl写到了一个文件中命名为minimal_amcl.launch。&lt;/p&gt;

&lt;p&gt;启动minimal_amcl.launch文件是在开机的第20秒左右，amcl.launch和minimal.launch共启动了两次，基本完全启动差不多是一到两分钟左右。目前不知道是什么原因，如果有知道的请告知，谢谢！&lt;/p&gt;

&lt;p&gt;首先，在家目录下创建一个名为aotu_runing的目录，在该目录下创建脚本文件minimal，内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;pre name=&quot;code&quot; class=&quot;plain&quot;&amp;gt;#!/bin/bash
source /opt/ros/indigo/setup.bash
source ~/.bashrc
export TURTLEBOT_BASE=kobuki
export TURTLEBOT_3D_SENSOR=kinect
export TURTLEBOT_MAP_FILE=&amp;lt;path_of_map_file&amp;gt;
source ~/catkin_ws/devel/setup.bash
export ROS_HOSTNAME=10.42.0.1
export ROS_MASTER_URI=http://10.42.0.1:11311
d='data +%Y%m%d-%H:%M:%S'
echo &quot;[$d]:minimal runing&quot; &amp;gt;&amp;gt; ~/print_log.txt
roslaunch turtlebot_bringup minimal_amcl.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中首先source ros路径，然后source bashrc和用户目录下的catkin_ws，因为catkin_ws目录下包含了路径规划算法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;pre name=&quot;code&quot; class=&quot;plain&quot;&amp;gt;d='data +%Y%m%d-%H:%M:%S'
echo &quot;[$d]:minimal runing&quot; &amp;gt;&amp;gt; ~/print_log.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打印出信息到家目录下。&lt;/p&gt;

&lt;p&gt;然后修改/etc/rc.local文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh -e&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/aotu_runing
./minimal
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;配置完成，当再次开机的时候，等待1到2分钟，会听到Turtlebot响声，amcl也一起启动。&lt;/p&gt;

</description>
        <pubDate>Mon, 05 Sep 2016 03:14:08 -0700</pubDate>
        <link>http://localhost:4000/2016/09/05/ros-startup-1/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/09/05/ros-startup-1/</guid>
        
        <category>ROS1</category>
        
        <category>Turtlebot2</category>
        
        <category>Startup</category>
        
        
      </item>
    
  </channel>
</rss>
