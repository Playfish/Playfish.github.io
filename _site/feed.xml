<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Playfish Blog</title>
    <description>关于个人成长历程、ROS设计 | Carl Zhang，About personal growth, ROS designer. | 这里是 @Playfish 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 13 May 2018 21:49:50 -0700</pubDate>
    <lastBuildDate>Sun, 13 May 2018 21:49:50 -0700</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>【ROS总结】发布ROS2包到ROS版本</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80075689&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在上一总结中，讲述了如何将&lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80039148&quot;&gt;ROS1的包发布到ROS版本&lt;/a&gt;（Indigo、jade、kinetic、lunar等），在这一节中，讲述如何把ROS2的包发送到ROS社区，比如发布到ROS2版本（ardent）。&lt;/p&gt;

&lt;p&gt;这个页面描述了如何准备在公共ROS 2 buildfarm上发布存储库。在你创建了一个包之后，这是将你的包引入到公开可用的Debian软件包(即：你将能够通过apt-get安装包。这个页面包含了ROS 2特定的指令，它取代了在ROS Wiki上的&lt;a href=&quot;http://wiki.ros.org/cn/bloom/Tutorials/FirstTimeRelease&quot;&gt;Bloom发布教程的第2部分&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;注意：早期的ROS 2版本的发布过程主要依赖于&lt;code class=&quot;highlighter-rouge&quot;&gt;git-bloom-release&lt;/code&gt;的子命令&lt;code class=&quot;highlighter-rouge&quot;&gt;bloom-release&lt;/code&gt;，而不是完整的开放版本工作流，所以可能会有问题。&lt;/p&gt;

&lt;h2 id=&quot;对比ros1-bloom不同&quot;&gt;对比ROS1 bloom不同&lt;/h2&gt;

&lt;p&gt;如果你在ROS1之前使用bloom发布过ROS包，ROS2的先决条件和ROS1差不多。然而，ROS 2还没有为你自动进行标记和版本控制的工具（没有等价于&lt;code class=&quot;highlighter-rouge&quot;&gt;catkin_create_changelog&lt;/code&gt;工具）。&lt;/p&gt;

&lt;h3 id=&quot;要求工具&quot;&gt;要求工具&lt;/h3&gt;

&lt;p&gt;对于ROS2的Ardent来说：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;bloom &amp;gt;= 0.6.2&lt;/li&gt;
  &lt;li&gt;catkin_pkg &amp;gt;= 0.4.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;过程&quot;&gt;过程&lt;/h3&gt;

&lt;h4 id=&quot;第一步changelog可选&quot;&gt;第一步：changelog（可选）&lt;/h4&gt;

&lt;p&gt;创建/更新CHANGELOG.rst，使用即将到来的新格式。注意，changelog严格来说是可选的，但它是非常推荐的。&lt;/p&gt;

&lt;p&gt;注意你的changelog格式中的错误可能会导致你的包发布问题。提交并将更改提交给变更日志。&lt;/p&gt;

&lt;h4 id=&quot;第二步标记包版本号&quot;&gt;第二步：标记包版本号&lt;/h4&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package.xml&amp;gt;&lt;/code&gt;中更新包的版本。版本号必须比前一个版本高。对于你的第一个版本，我们建议0.0.1或1.0.0。提交并推动这个变更。&lt;/p&gt;

&lt;p&gt;注意，你不能使用以前使用的版本号(参见下面)。一些包释放到ROS 1和ROS 2，但是由于这个需求，必须使用不同的版本控制系列。ROS包通常不遵循严格的&lt;a href=&quot;https://semver.org/&quot;&gt;语义版本&lt;/a&gt;控制，所以不要过分担心。如果你想了解其他人已经做了什么，请使用ROS 1发布包中的0.x.x或1.x.x系列和ROS 2发布包中的1.x.x或2.x.x系列。&lt;/p&gt;

&lt;h4 id=&quot;第三步标记你的包&quot;&gt;第三步：标记你的包&lt;/h4&gt;

&lt;p&gt;创建一个与你刚刚输入到package.xml中的版本号相匹配的标记，在提交时，会遇到版本号。现在你知道了不能重用版本号的原因——git只允许在存储库中使用给定名称的一个标记。&lt;/p&gt;

&lt;h4 id=&quot;第四步确保你的bloom和catkin_pkg是最新版本&quot;&gt;第四步：确保你的bloom和catkin_pkg是最新版本&lt;/h4&gt;

&lt;p&gt;查看以上版本要求，运行以下命令追踪当前版本：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install python-catkin-pkg python-bloom 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;第五步设置ros-2环境变量&quot;&gt;第五步：设置ROS 2环境变量&lt;/h4&gt;

&lt;p&gt;ROS 2使用的是全新的存储库，该版本的所有索引保存在https://github.com/ros2/rosdistro，forked该存储库。你可以通过设置ROSDISTRO_INDEX_URL环境变量来配置bloom。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ROSDISTRO_INDEX_URL='https://raw.githubusercontent.com/ros2/rosdistro/ros2/index.yaml'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;导出这个之后，你将能够在你的bloom-release终端命令中使用ROS 2发行版的&lt;code class=&quot;highlighter-rouge&quot;&gt;ardent&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bouncy&lt;/code&gt;等名称。&lt;/p&gt;

&lt;h3 id=&quot;下一步&quot;&gt;下一步&lt;/h3&gt;

&lt;p&gt;现在，你的存储库设置完毕。你已经手动完成ROS 2在&lt;a href=&quot;http://wiki.ros.org/cn/bloom/Tutorials/PrepareUpstream&quot;&gt;这个界面&lt;/a&gt;的内容&lt;/p&gt;

&lt;p&gt;返回到ROS Wiki上的&lt;a href=&quot;http://wiki.ros.org/cn/bloom/Tutorials/FirstTimeRelease&quot;&gt;Bloom发布&lt;/a&gt;教程，并继续“创建一个发布存储库”。&lt;/p&gt;

</description>
        <pubDate>Wed, 25 Apr 2018 04:40:44 -0700</pubDate>
        <link>http://localhost:4000/2018/04/25/releaseros2-into-rosdistro/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/25/releaseros2-into-rosdistro/</guid>
        
        <category>ROS2</category>
        
        <category>Release</category>
        
        
      </item>
    
      <item>
        <title>【ROS总结】发布ROS1包之文档编写</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80041201&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在上一节中，讲述了如何发布一个包到ROS社区，这一节将讲述，如何在wiki界面编写ROS包说明文档、教程。&lt;/p&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;登录wiki官网，创建界面编辑账号&lt;/li&gt;
  &lt;li&gt;向ROS社区提交wiki页面编辑权限，取得白名单&lt;/li&gt;
  &lt;li&gt;编辑ROS包文档&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;创建wiki账号&quot;&gt;创建wiki账号&lt;/h2&gt;

&lt;p&gt;登录wiki.ros.org，选择登录，创建账户&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-with-document/wiki_login.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入用户名密码
&lt;img src=&quot;/img/in-post/release-ros1-with-document/wiki_create_account.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建完成后，选择登录，登录成功会将显示：
&lt;img src=&quot;/img/in-post/release-ros1-with-document/wiki_whitelists.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击界面获取白名单。&lt;/p&gt;

&lt;h2 id=&quot;wiki白名单&quot;&gt;wiki白名单&lt;/h2&gt;

&lt;p&gt;在github上，登录当前github账号，在白名单注册界面：https://github.com/ros-infrastructure/roswiki/issues/139&lt;/p&gt;

&lt;p&gt;发布请求，比如我的wiki用户为playfish，输入，comment即可。
&lt;img src=&quot;/img/in-post/release-ros1-with-document/get_whitelists.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果一切正常，大家可以登录http://wiki.ros.org/UserGroup，查看自己的名字是否加入。&lt;/p&gt;

&lt;h2 id=&quot;编辑文档&quot;&gt;编辑文档&lt;/h2&gt;

&lt;p&gt;现在编写自己ROS包的使用文档，该文档地址应当在package.xml里面表明，比如我的cht10_node包的package.xml地址为：
&lt;img src=&quot;/img/in-post/release-ros1-with-document/package_xml.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此，输入当前第一个网址 http://ros.org/wiki/cht10_node&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-with-document/package_template.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击packageTemplate，来创建界面。
&lt;img src=&quot;/img/in-post/release-ros1-with-document/write_wiki.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在packageHeader中添加自己的cht10_node包名，该界面会自动链接到cht10_node包。&lt;/p&gt;

&lt;p&gt;创建完成后，即可生成界面，文档编辑结束。&lt;/p&gt;

</description>
        <pubDate>Sun, 22 Apr 2018 11:35:30 -0700</pubDate>
        <link>http://localhost:4000/2018/04/22/releaseros1-with-document/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/22/releaseros1-with-document/</guid>
        
        <category>ROS1</category>
        
        <category>Release</category>
        
        <category>Document</category>
        
        <category>wiki</category>
        
        
      </item>
    
      <item>
        <title>【ROS总结】发布ROS1包到ROS版本</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80039148&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在ROS开发过程中，想要发布自己的包贡献到ROS社区，也就是想要自己的包可以通过apt-get的形式进行下载，这样可以避免每次源码编译的时候会遇到很多坑的情况，不过想要发布ROS包到ROS社区需要如下能力：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;长期维护能力：ROS包会一直迭代更新，因此自己的包也应具有长期维护能力，当然，稳定版本后可以不用长期维护。&lt;/li&gt;
  &lt;li&gt;开源精神：因为ROS包遵循BSD协议，会要求将包开源后才可以上传到ROS社区，所以将自己的包发布到ROS社区，最好有开源精神。&lt;/li&gt;
  &lt;li&gt;文档更新：包的更新也伴随这文档更新，当然也不是绝对的，不过最好有包的使用文档，也就是wiki上。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果以上的可以做到，那么，恭喜你，可以作为开源成员加入到ROS大家庭来，开源自己代码，共享社区。&lt;/p&gt;

&lt;p&gt;本教程只是单纯的介绍如何发布自己的包到ROS社区，并且，发布后如何通过apt-get获取下载，关于文档界面编写，也就是wiki说明，会在后面进行说明。&lt;/p&gt;

&lt;p&gt;一般发布自己ROS包有如下步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;具有github账号与要发布的存储库地址，发布存储库(bloom-release生成的包路径)，wiki白名单(文档界面做准备)&lt;/li&gt;
  &lt;li&gt;发布前准备工作，bloom安装(ROS1推荐使用bloom-release进行一键操作)&lt;/li&gt;
  &lt;li&gt;同步到ROS社区&lt;/li&gt;
  &lt;li&gt;等待ROS社区的ROS包版本迭代&lt;/li&gt;
  &lt;li&gt;编辑wiki文档教程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上步骤完成后，就可以进行apt-get形式下载自己的包了。假如自己的包为cht10_node，那么可以使用如下命令进行安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install ros-&amp;lt;rosdistro&amp;gt;-cht10-node 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中将&lt;rosdistro&gt;替换成自己的ROS版本，也就是自己的包发布到的ROS版本中，比如自己的包发布到了kinetic中，那么就是：&lt;/rosdistro&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo  apt-get  install ros-kinetic-cht10-node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意：并不是自己把包发布到ROS社区就等于所有的ROS版本都可以下载，只有发布到对应ROS版本才可以。也就是说要想把自己的包发布到ROS所有版本，必须把自己的包发布到所有的版本中，比如Indigo、Jade、Kinetic、Luna、Melodic中。&lt;/p&gt;

&lt;p&gt;ROS发布需要bloom-release包，我已经将ROS的bloom-release包如何使用翻译到wiki上，大家可以查看教程&lt;/p&gt;

&lt;p&gt;http://wiki.ros.org/cn/bloom&lt;/p&gt;

&lt;p&gt;或者查看英文教程：&lt;/p&gt;

&lt;p&gt;http://wiki.ros.org/bloom&lt;/p&gt;

&lt;p&gt;以后会编写如何发布ROS2的包到ROS社区教程。&lt;/p&gt;

&lt;p&gt;大家也可以看Mastering ROS for Robotics Programming中的Maintaining the ROS package 部分。&lt;/p&gt;

&lt;p&gt;Mastering ROS for Robotics Programming书籍下载：https://download.csdn.net/download/u011118482/10402380 (包含英文和中文翻译)。&lt;/p&gt;

&lt;p&gt;没有0积分下载，大家也可以进入ROS群进行下载。&lt;/p&gt;

&lt;h2 id=&quot;发布前的准备&quot;&gt;发布前的准备&lt;/h2&gt;

&lt;h3 id=&quot;创建github存储库&quot;&gt;创建github存储库&lt;/h3&gt;

&lt;p&gt;登录http://github.com/，创建自己的github账号，创建完成后，创建要发布的ROS存储库，例如包名为之前教程的cht10_node，那么创建cht10_node目录。&lt;/p&gt;

&lt;p&gt;我的存储库为：https://github.com/Playfish/cht10_node&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/cht10_repo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建完成后，上传自己的代码到github的cht10_node存储库中。完成如上图。&lt;/p&gt;

&lt;p&gt;注意：发布ROS包应有如下内容，否则无法发布：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CHANGELOG.rst：必须有该文件，该文件内容，可以查看我写的，格式一般为包+版本(日期)+分隔符+修订日志&lt;/li&gt;
  &lt;li&gt;package.xml：内容必须有maintainer子项，版本号必须与CHANGELOG中的版本一致，比如都为0.0.1，包名也一样。&lt;/li&gt;
  &lt;li&gt;tag：版本标记。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;生成tag用于以下发布ROS包追踪：&lt;/p&gt;

&lt;p&gt;点击当前界面上的release按钮，创建一个release tag：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/cht10_release.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;保存。&lt;/p&gt;

&lt;h3 id=&quot;创建github-release存储库&quot;&gt;创建github release存储库&lt;/h3&gt;

&lt;p&gt;创建要发布的ROS完成后，为ROS包创建生成的release存储库，我创建的名为cht10_node_release，最好创建为包名_release。这个存储库为空即可，必须勾选初始化ReadeMe.md选项，生成的包版本更新日志将存放在这里。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/cht10_release_repo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完成后即可，不用再管这个存储库，后期发布完成后，可以查看内容。&lt;/p&gt;
&lt;h3 id=&quot;fork-ros社区版本包存储库&quot;&gt;fork ROS社区版本包存储库&lt;/h3&gt;

&lt;p&gt;保证自己的github账号处于登录状态，点击：http://github.com/ros/rosdistro 。随后点击fork。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/fork_rosdistro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完成后，可以看到自己有了rosdistro存储库：
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/playfish_rosdistro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;发布ros包&quot;&gt;发布ROS包&lt;/h2&gt;
&lt;p&gt;发布前的准备完成后，在自己的Ubuntu下，安装bloom_release包，安装命令如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install python-bloom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装完成后，使用如下命令进行发布：&lt;/p&gt;

&lt;p&gt;以下配置只会在第一次产生。&lt;/p&gt;

&lt;p&gt;运行以下命令进行发布与配置ROS Release包，比如把cht10_node发布到kinetic版本上：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bloom-release --rosdistro kinetic --track kinetic cht10_node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中–rosdistro后的选项为发布到kinetic版本，–track选项为追踪选项，默认为ROS分布式版本，最后的cht10_node为当前存储库名称。&lt;/p&gt;

&lt;p&gt;运行命令产生如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入之前创建的发布的release存储库：https://github.com/Playfish/cht10_node_release.git&lt;/p&gt;

&lt;p&gt;选择Y确定创建追踪。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入当前存储库名称：cht10_node&lt;/p&gt;

&lt;p&gt;输入当前存储库地址：https://github.com/Playfish/cht10_node.git&lt;/p&gt;

&lt;p&gt;随后一路按下回车为默认选项。直到遇到输入用户名、密码为止，在此过程中会遇到很多次输入账号密码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入github账号密码，回车。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;产生debian配置文件：y&lt;/p&gt;

&lt;p&gt;输入当前github用户名密码继续。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;产生debian包后，输入用户名密码发布tag。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;编辑当前ROS包另一个配置，文档配置以及版本状态，输入默认即可。&lt;/p&gt;

&lt;p&gt;注意：turn on pull request testing选择默认为N，如果选择y需要额外配置，不需要打开，我这里是为以后做准备。&lt;/p&gt;

&lt;p&gt;额外的配置查看：https://github.com/ros/rosdistro/pull/17576&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;向rosdistro存储库的kinetic目录下的分布式文件添加当前包内容。&lt;/p&gt;

&lt;p&gt;随后向rosdistro存储库提交请求，输入当前github账号密码。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;生成请求日志。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完成后，将提示已经发布完成请求，大家可以点击最后的链接查看当前请求。&lt;/p&gt;
&lt;h2 id=&quot;确认工作&quot;&gt;确认工作&lt;/h2&gt;

&lt;p&gt;请求完成后，大家打开之前创建的空白发布存储库，可以看到已经生成了很多生成deb包的规则文件，例如我的：&lt;/p&gt;

&lt;p&gt;https://github.com/Playfish/cht10_node_release.git&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/cht10_release_fill.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大家可以到https://github.com/ros/rosdistro/pulls，查看发布情况。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/report_rosdistro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果一切正常，ROS维护人员将合并当前请求，合并完成后。&lt;/p&gt;

&lt;p&gt;到 讨论论坛中https://discourse.ros.org/查看当前版本下的包迭代情况，一般为一个月ROS包版本迭代一次。&lt;/p&gt;

&lt;p&gt;迭代完成后，可以看到自己的包已经存放到了http://packages.ros.org下。&lt;/p&gt;

&lt;p&gt;使用apt-get update 更新后，可以下载自己的包了，比如我的包可以用如下命令下载：&lt;/p&gt;

&lt;p&gt;sudo  apt-get  install  ros-kinetic-cht10-node&lt;/p&gt;

&lt;p&gt;ROS包的发布过程这一节告一段落，下一步讲述如何&lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80041201&quot;&gt;编辑cht10_node生成的wiki文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;注意，如果要生成wiki文档，需要在package.xml里面添加url指向wiki。&lt;/p&gt;

</description>
        <pubDate>Sun, 22 Apr 2018 10:48:13 -0700</pubDate>
        <link>http://localhost:4000/2018/04/22/releaseros1-into-rosdistro/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/22/releaseros1-into-rosdistro/</guid>
        
        <category>ROS1</category>
        
        <category>Release</category>
        
        
      </item>
    
      <item>
        <title>【ROS总结】点激光扫描仪数据发布（驱动编写）</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/78632555&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在使用ROS的过程中，不可避免的会遇到要自己手动编写驱动、节点、行为库、服务、消息等内容，尤其是需要一些传感器，而所需传感器没有相关ROS驱动时，下面将讲述的是在使用的传感器中，没有ROS驱动时，我们将如何使用该传感器。&lt;/p&gt;

&lt;p&gt;在接下来的博客中将根据本身经验来编写一些ROS相关内容，权当是作为记忆来分享。&lt;/p&gt;

&lt;h2 id=&quot;ros驱动点激光扫描仪&quot;&gt;ROS驱动——点激光扫描仪&lt;/h2&gt;

&lt;p&gt;下面将讲述使用ROS官方未有的传感器来作为样例，我使用的是莱旭光电的CHT-10点激光传感器作为 介绍，首先这款传感器通信协议部分比较简单，基本上打开串口就可以读出数据，在将数据进行转换就可以得到想要的距离，比较方便，免去复杂的部分，对教程也有帮助，毕竟教程主要讲述的是ROS驱动部分。&lt;/p&gt;

&lt;p&gt;相关ROS驱动代码可以在github上找到进行下载：https://github.com/Playfish/cht10_node&lt;/p&gt;

&lt;p&gt;CHT-10是点激光，扫描范围是0.05-10m，真实的应该是0.15-10m，10m未测试，不过0.15盲区还是有的。&lt;/p&gt;

&lt;p&gt;下图是CHT-10的通信协议部分介绍：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/write-laserscan-publisher/laserscan_protocol.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到想要的数据在9~12位（四字节），得到的数据需要除以1000才能得到真实的距离（米），ROS消息中基本单位是米。&lt;/p&gt;

&lt;h3 id=&quot;消息选定&quot;&gt;消息选定&lt;/h3&gt;

&lt;p&gt;关于选择什么消息作为该传感器的ROS消息，这个相对来说不是很重要，不过作为通用项来说，尽量向通用靠近（即使用ROS官方消息定义，而不是自己定义消息）。目前激光消息的话，有两个选择，第一个是sensor_msgs/LaserScan消息类型，不过该消息类型适合有角度的传感器，即180°或360°的2D雷达或激光，而目前使用的激光是单点类型，和激光笔差不多，只有一个点，那么可以选择sensor_msgs/Range消息类型，该消息类型适用于超声波传感器、红外传感器单点类型，CHT-10就用这个类型。&lt;/p&gt;

&lt;p&gt;关于该消息：可以查看&lt;a href=&quot;docs.ros.org/api/sensor_msgs/html/msg/Range.html&quot;&gt;sensor_msgs/Range&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;

&lt;p&gt;传感器选型选定、通信消息选定，那么接下来还需要做：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Frame_id：Frame在ROS中作用至关重要，消息将和TF绑定才可以读取数据，在这里作为通用可配置，暂定内容为：laser，用户可自定义设置（通过ROS Parameters设置）。&lt;/li&gt;
  &lt;li&gt;串口：避免和其他传感器串口冲突，因此在这里预留出一个串口设置参数，用户可以自定义设置（通过ROS Parameters设置）。&lt;/li&gt;
  &lt;li&gt;话题：消息内容需要通过话题发布，并且话题需要唯一，不然容易崩溃，在这里选择话题为“range”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然以上部分可以不考虑，这个是作为通用型需要考虑的，暂时可以先忘记以上部分，下面开启代码部分&lt;/p&gt;

&lt;h3 id=&quot;测试代码编写&quot;&gt;测试代码编写&lt;/h3&gt;

&lt;p&gt;在这部分，主要先编写测试代码，如果测试代码无问题，就可以写到node中，测试代码和ROS无关系，只是通过串口读取数据，并且在终端显示出来，整体思路如下：&lt;/p&gt;

&lt;p&gt;传感器选择 -&amp;gt; 测试程序测试（类似串口助手） -&amp;gt; ROS node绑定（将测试程序读取部分加入到ROS中） -&amp;gt; 将node加入到nodelet中封装&lt;/p&gt;

&lt;p&gt;下面是测试程序部分，也可以在cht10_node/test中找到，名为&lt;a href=&quot;https://github.com/Playfish/cht10_node/blob/master/test/test_cht10.cpp&quot;&gt;test_cht10.cpp&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #include &amp;lt;string&amp;gt;  
    #include &amp;lt;cht10_node/seiral_func.hpp&amp;gt;  
    #include &amp;lt;cstdlib&amp;gt;  
      
    #include &amp;lt;iostream&amp;gt;  
    #include &amp;lt;stdint.h&amp;gt;  
    #define BUFSIZE 17  
      
    int main(int argc, char** argv){  
      cht10_seiral_func::Cht10Driver cht10driver_;  
      
      std::string serialNumber_;  
      serialNumber_ = &quot;/dev/ttyUSB0&quot;;  
      int baudRate_ = 115200;  
      
      std::stringstream ostream;  
      int fd, len, rcv_cnt;  
      bool success_flag;  
      char buf[40], temp_buf[BUFSIZE],result_buf[BUFSIZE];  
      int laser_data=0;  
      char data_buf[4];  
      rcv_cnt = 0;  
      success_flag = false;  
      memset(buf, 0xba, sizeof(buf));  
      memset(temp_buf, 0xba, sizeof(temp_buf));  
      memset(result_buf, 0xba, sizeof(result_buf));  
      
      fd = open(serialNumber_.c_str(), O_RDWR | O_NOCTTY | O_NDELAY );  
      if(fd &amp;lt; 0){  
        std::cout&amp;lt;&amp;lt;&quot;Open Serial: &quot;&amp;lt;&amp;lt;serialNumber_.c_str()&amp;lt;&amp;lt;&quot; Error!&quot;;  
        exit(0);  
      }  
        
      cht10driver_.UART0_Init(fd,baudRate_,0,8,1,'N');  
      while(1){  
        len = cht10driver_.UART0_Recv(fd, buf,40);  
        if(len&amp;gt;0){  
          for(int i = 0; i &amp;lt; len; i++){  
            if(rcv_cnt&amp;lt;=BUFSIZE){    
              result_buf[rcv_cnt++] = buf[i];  
              if(rcv_cnt == BUFSIZE){  
                success_flag = true;  
              }  
            }//end if  
            else{  
              /**** 
              *  checkout received data 
              */  
    //          std::cout&amp;lt;&amp;lt;&quot;Received data, with :[&quot;;  
    //          for(int j=0;j&amp;lt;BUFSIZE;j++){  
    //            printf(&quot;%c &quot;,(unsigned char) result_buf[j]);  
    //          }  
    //          printf(&quot;] \n&quot;);  
              success_flag = false;  
      
              for(int count = 0; count &amp;lt; 4; count++){  
                data_buf[count] = result_buf[9+count];  
              }  
              sscanf(data_buf, &quot;%x&quot;, &amp;amp;laser_data);  
              std::cout&amp;lt;&amp;lt;&quot;sensor data:&quot;&amp;lt;&amp;lt;laser_data&amp;lt;&amp;lt;&quot;, Distance: &quot;&amp;lt;&amp;lt;(double)laser_data/1000&amp;lt;&amp;lt;std::endl;  
              /**** 
               *  data writing end 
               */  
              if('~' == buf[i]){  
                rcv_cnt = 0;  
                result_buf[rcv_cnt++] = buf[i];  
              }  
            }//end else  
          }//end for      
        }  
      }  
      
        
    }  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我将串口部分封装成一个类名为&lt;code class=&quot;highlighter-rouge&quot;&gt;Cht10Driver&lt;/code&gt;，该类包含串口读/写部分、初始化。&lt;/p&gt;

&lt;p&gt;通过使用&lt;code class=&quot;highlighter-rouge&quot;&gt;catkin_make&lt;/code&gt;可以得到一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;test_cht10&lt;/code&gt;的可执行文件，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;./test_cht10&lt;/code&gt;可以运行，将CHT-10插入到电脑上，并且电脑只有一个ttyUSB0，就可以读取数据，数据将显示为sensor data: 传感器毫米数据， Distance: 传感器米数据。&lt;/p&gt;

&lt;h3 id=&quot;ros驱动编写&quot;&gt;ROS驱动编写&lt;/h3&gt;

&lt;p&gt;上部分讲述了测试程序编写，主要作用是通过串口读取传感器数据，那么得到传感器数据之后，就可以将传感器数据填充到ROS消息中，然后通过话题形式发布出去，如下是将传感器数据填充到ROS消息并封装成nodelet类的主要部分：&lt;/p&gt;

&lt;p&gt;完整代码可以查看： &lt;a href=&quot;https://github.com/Playfish/cht10_node/blob/master/src/cht10_node.cpp&quot;&gt;cht10_node.cpp&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    /** 
     * @file /Cht10_serial_func/src/Cht10_serial_func.cpp 
     * 
     * @brief Implementation for dirver with read data from Cht10 nodelet 
     * 
     * @author Carl 
     * 
     **/  
      
    /***************************************************************************** 
     ** Includes 
     *****************************************************************************/  
    #include &amp;lt;string&amp;gt;  
    #include &amp;lt;ros/ros.h&amp;gt;  
    #include &amp;lt;std_msgs/String.h&amp;gt;  
    #include &amp;lt;nodelet/nodelet.h&amp;gt;  
    #include &amp;lt;ecl/threads/thread.hpp&amp;gt;  
    #include &amp;lt;sensor_msgs/LaserScan.h&amp;gt;    
    #include &amp;lt;sensor_msgs/Range.h&amp;gt;    
    #include &amp;lt;pluginlib/class_list_macros.h&amp;gt;  
    #include &amp;lt;cht10_node/seiral_func.hpp&amp;gt;  
      
      
    namespace cht10_seiral_func{  
      
    class Cht10Func : public nodelet::Nodelet{  
    #define BUFSIZE 17  
    #define SCALE 1000  
      
    public:  
      Cht10Func() : shutdown_requested_(false),serialNumber_(&quot;/dev/USB0&quot;),frame_id(&quot;laser&quot;){}  
      
      ~Cht10Func(){  
        NODELET_DEBUG_STREAM(&quot;Waiting for update thread to finish.&quot;);  
        shutdown_requested_ = true;  
        update_thread_.join();  
      }  
      
      virtual void onInit(){  
      
        ros::NodeHandle nh = this-&amp;gt;getPrivateNodeHandle();  
        std::string name = nh.getUnresolvedNamespace();  
        nh.getParam(&quot;serialNumber&quot;, serialNumber_);  
        nh.getParam(&quot;baudRate&quot;, baudRate_);  
        nh.getParam(&quot;frame_id&quot;, frame_id);  
        rcv_cnt = 0;  
        success_flag = 0;  
      
        fd = open(serialNumber_.c_str(), O_RDWR | O_NOCTTY | O_NDELAY );  
        if(fd &amp;lt; 0){  
          ROS_ERROR_STREAM(&quot;Open Serial: &quot;&amp;lt;&amp;lt;serialNumber_.c_str()&amp;lt;&amp;lt;&quot; Error!&quot;);  
          exit(0);  
        }  
      
        int countSeq=0;  
        scan_pub = nh.advertise&amp;lt;sensor_msgs::Range&amp;gt;(&quot;range&quot;,100);  
        memset(buf, 0, sizeof(buf));  
        memset(temp_buf, 0, sizeof(temp_buf));  
        memset(result_buf, 0, sizeof(result_buf));  
        Cht10driver_.UART0_Init(fd,baudRate_,0,8,1,'N');  
        ROS_INFO_STREAM(&quot;Open serial: [&quot;&amp;lt;&amp;lt; serialNumber_.c_str() &amp;lt;&amp;lt;&quot; ] successful, with idex: &quot;&amp;lt;&amp;lt;fd&amp;lt;&amp;lt;&quot;.&quot;);  
        NODELET_INFO_STREAM(&quot;Cht10Func initialised. Spinning up update thread ... [&quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &quot;]&quot;);  
        update_thread_.start(&amp;amp;Cht10Func::update, *this);  
      }  
      
      double data_to_meters(int &amp;amp;data, int scale){  
        return (double)data/scale;  
      }  
      
      void publish_scan(ros::Publisher *pub,  
                        double nodes, ros::Time start,  
                        std::string frame_id){  
      
        float final_range;  
        sensor_msgs::Range range_msg;  
        range_msg.field_of_view = 0.05235988;  
        range_msg.max_range = 10.0;  
        range_msg.min_range = 0.05;  
        range_msg.header.frame_id = frame_id;  
        range_msg.radiation_type = sensor_msgs::Range::INFRARED;  
        if(nodes &amp;gt; range_msg.max_range){  
          final_range = std::numeric_limits&amp;lt;float&amp;gt;::infinity();  
        }else if(nodes &amp;lt; range_msg.min_range){  
          final_range = -std::numeric_limits&amp;lt;float&amp;gt;::infinity();  
        }else{  
          final_range = nodes;  
        }  
        range_msg.header.stamp = start;  
        range_msg.header.seq = countSeq;  
        range_msg.range = final_range;  
        scan_pub.publish(range_msg);  
      
      }  
      
      bool get_scan_data(){  
        len = Cht10driver_.UART0_Recv(fd, buf,40);  
        if(len&amp;gt;0){  
          for(int i = 0; i &amp;lt; len; i++){  
            if(rcv_cnt&amp;lt;=BUFSIZE){    
              result_buf[rcv_cnt++] = buf[i];  
              if(rcv_cnt == BUFSIZE){  
                success_flag = true;  
              }  
            }//end if  
            else{  
              /**** 
              *  checkout received data 
              */  
              success_flag = false;  
               for(int count = 0; count &amp;lt; 4; count++){  
                data_buf[count] = result_buf[9+count];  
              }  
              sscanf(data_buf, &quot;%x&quot;, &amp;amp;laser_data);  
                
              //std::cout&amp;lt;&amp;lt;&quot;sensor data:&quot;&amp;lt;&amp;lt;laser_data&amp;lt;&amp;lt;std::endl;  
      
              /**** 
               *  data writing end 
               */  
              if('~' == buf[i]){  
                rcv_cnt = 0;  
                result_buf[rcv_cnt++] = buf[i];  
              }  
            }//end else  
          }//end for      
        }  
      }  
    private:  
      void update(){  
        rcv_cnt = 0;  
        success_flag = 0;  
        laser_data = 0;  
        ros::Rate spin_rate(50);  
        memset(buf, 0, sizeof(buf));  
        memset(temp_buf, 0, sizeof(temp_buf));  
        memset(result_buf, 0, sizeof(result_buf));  
        ROS_INFO_STREAM(&quot;Begin receive data from &quot;&amp;lt;&amp;lt;serialNumber_.c_str()&amp;lt;&amp;lt;&quot;, with idex:&quot;&amp;lt;&amp;lt;fd&amp;lt;&amp;lt;&quot;.&quot;);  
        fd = open(serialNumber_.c_str(), O_RDWR | O_NOCTTY | O_NDELAY );  
        Cht10driver_.UART0_Init(fd,baudRate_,0,8,1,'N');  
        while (! shutdown_requested_ &amp;amp;&amp;amp; ros::ok())  
        {  
          start_scan_time = ros::Time::now();  
          success_flag = get_scan_data();  
                
          //Send data  
          publish_scan(&amp;amp;scan_pub, data_to_meters(laser_data,SCALE),  
                           start_scan_time, frame_id);  
          spin_rate.sleep();  
      
          countSeq++;  
        }  
      
        ROS_INFO_STREAM(&quot;Shotdown and close serial: &quot;&amp;lt;&amp;lt;serialNumber_.c_str()&amp;lt;&amp;lt;&quot;.&quot;);  
        Cht10driver_.UART0_Close(fd);  
      }  
    private:  
      int fd, len, rcv_cnt;  
      int success_flag;  
      char buf[40], temp_buf[BUFSIZE],result_buf[BUFSIZE];  
        
      Cht10Driver Cht10driver_;  
      ecl::Thread update_thread_;  
      bool shutdown_requested_;  
      ros::Publisher scan_pub;  
      int laser_data;  
      char data_buf[4];  
      // ROS Parameters  
      std::string serialNumber_;  
      int baudRate_;  
      int countSeq;  
        
      std::string frame_id;  
      
      ros::Time start_scan_time;  
    };  
      
    } //namespace Cht10_serial_func  
    PLUGINLIB_EXPORT_CLASS(cht10_seiral_func::Cht10Func,  
    nodelet::Nodelet);  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中get_scan_data()函数，就是测试代码内容，得到数据后将数据发送到publish_scan()函数中，就可以发布传感器数据了。&lt;/p&gt;

&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;

&lt;p&gt;代码完成后，按照格式进行编写CMakeList、package文件，运行catkin_make就可以得到名为cht10_node.so动态库，运行launch文件即可加载，命令如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch cht10_node standalone.launch 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果一切成才，运行rostopic list 可以得到/range话题。&lt;/p&gt;

&lt;p&gt;使用rostopic echo /range就可以得到传感器的ROS消息内容，包括传感器距离。&lt;/p&gt;

&lt;p&gt;或者直接运行&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch cht10_node view_range.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;就可以看到图形化形式为传感器数据。&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Nov 2017 09:05:58 -0800</pubDate>
        <link>http://localhost:4000/2017/11/25/write-laserscan-publisher/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/25/write-laserscan-publisher/</guid>
        
        <category>ROS1</category>
        
        <category>Release</category>
        
        <category>driver</category>
        
        
      </item>
    
      <item>
        <title>ros_arduino_bridge使用总结</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/77528798&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;关于ROS和Arduino通信方式，刚开始大多使用的是rosserial_arduino这个库，随后又诞生了一个新的库名为ros_arduino_bridge，两者对比如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://wiki.ros.org/rosserial_arduino&quot;&gt;rosserial_arduino&lt;/a&gt;：由于将Arduino内的程序写成ros节点形式，所以能够快速的通过ROS控制Arduino，并且可以忽略通信协议层，与之相同的还有rosserial_stm32f1库，但是由于将Arduino作为ROS节点，不可避免的产生通信延时较大的问题，而且运行该库是通过rosserial_python包内的serial_node.py启动，该脚本使用了tcpip协议，有点大材小用，uno速率会跟不上，导致启动过程中一崩溃很难在连接上的问题，学习ROS可以使用。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://wiki.ros.org/rosserial_arduino_bridge&quot;&gt;ros_arduino_bridge&lt;/a&gt;：是自定义通信协议方式来与Arduino进行通信，和大多数控制形式一致，将通信协议固定可以让初学者在使用过程中了解通信协议，由于是自定义通信协议形式，可以即插即用，和rosserial_arduino有本质差别，不过在使用过程中需要自己配置，所以需要有一定的arudino编程基础，早期的EAI dashgo D1采用的就是这种形式，使用这个库可以缩短底盘开发时间，并且Arduino有很多开源包供使用，会相对轻松一些。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于如何使用rosserial_arduino_bridge，作者在github的&lt;a href=&quot;https://github.com/hbrobotics/ros_arduino_bridge/blob/indigo-devel/README.md&quot;&gt;Readme&lt;/a&gt;中写的很清楚，当然，是使用英文编写，如果大家想要查看中文，&lt;a href=&quot;blog.csdn.net/github_30605157/article/details/51344150/&quot;&gt;这里&lt;/a&gt;是一个很好的方式，我做的小车就是参考这篇博客，写的很清楚。&lt;/p&gt;

&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;
&lt;h3 id=&quot;编码器&quot;&gt;编码器&lt;/h3&gt;

&lt;p&gt;关于如何使用我就不在赘述了，大家可以参考上面博客进行查看，作者代码在github上也有给出。查看作者代码发现作者应该用的Arduino mega板，电机控制器是L298N模块，我使用的是Arduino Uno板作为测试，电机控制器也选用的L298N，所以更改代码如下：&lt;/p&gt;

&lt;p&gt;将&lt;a href=&quot;https://github.com/Sunlcy/ros_arduino_bridge/tree/indigo-devel-saturnbot-pid-tuning/ros_arduino_firmware/src/libraries/ROSArduinoBridge/encoder_driver.h&quot;&gt;ros_arduino_bridge/ros_arduino_firmware/src/libraries/ROSArduinoBridge/encoder_driver.h&lt;/a&gt;的内容：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#ifdef ARDUINO_MY_COUNTER  
  #define LEFT_ENC_A 2  
  #define LEFT_ENC_B 22  
  #define RIGHT_ENC_A 21  
  #define RIGHT_ENC_B 24  
  void initEncoders();  
  void leftEncoderEvent();  
  void rightEncoderEvent();  
#endif 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;修改为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #ifdef ARDUINO_MY_COUNTER  
      #define LEFT_ENC_A 2  
      #define LEFT_ENC_B 4  
      #define RIGHT_ENC_A 3  
      #define RIGHT_ENC_B 11  
      void initEncoders();  
      void leftEncoderEvent();  
      void rightEncoderEvent();  
    #endif  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;关于这点需要注意，由于Arduino Uno只有两个中断，所以只能将两个中断分开给左编码器和右编码器，即Uno两个中断对应硬件分别为2和3，其中引脚2对应中断号为0，引脚3对应中断号为1，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ros-arduino-bridge-usage/arduino_pin.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;修改完成后，还需修改&lt;a href=&quot;https://github.com/Sunlcy/ros_arduino_bridge/tree/indigo-devel-saturnbot-pid-tuning/ros_arduino_firmware/src/libraries/ROSArduinoBridge/encoder_driver.ino&quot;&gt;ros_arduino_bridge/ros_arduino_firmware/src/libraries/ROSArduinoBridge/encoder_driver.ino&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;将内容&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    void initEncoders(){  
      pinMode(LEFT_ENC_A, INPUT);  
      pinMode(LEFT_ENC_B, INPUT);  
      pinMode(RIGHT_ENC_A, INPUT);  
      pinMode(RIGHT_ENC_B, INPUT);  
      
      attachInterrupt(0, leftEncoderEvent, CHANGE);  
      attachInterrupt(2, rightEncoderEvent, CHANGE);  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;修改为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    void initEncoders(){  
      pinMode(LEFT_ENC_A, INPUT);  
      pinMode(LEFT_ENC_B, INPUT);  
      pinMode(RIGHT_ENC_A, INPUT);  
      pinMode(RIGHT_ENC_B, INPUT);  
      
      attachInterrupt(0, leftEncoderEvent, CHANGE);  
      attachInterrupt(1, rightEncoderEvent, CHANGE);  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意变化，mega有四个中断，而Uno只有两个，所以需要修改为中断0、中断1。不然造成的结果是有一个电机编码器无数据，一直为0。&lt;/p&gt;

&lt;p&gt;同样的，如果引脚类型不对应也会造成错误，如右电机，我将编码器A接上引脚3，编码器B接上引脚12，造成结果是右编码器数据一直在累加，即使电机没有转动，这是由于引脚3作为中断，类型为PWN引脚，而引脚12则为数字引脚，所以需要将编码器B接上引脚11，这是由于引脚11也为PWM类型，这样就不会造成错误。&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Nov 2017 09:04:46 -0800</pubDate>
        <link>http://localhost:4000/2017/11/25/ros-arduino-bridge-usage/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/25/ros-arduino-bridge-usage/</guid>
        
        <category>ROS1</category>
        
        <category>ros_arduino_bridge</category>
        
        
      </item>
    
  </channel>
</rss>
