<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Playfish Blog</title>
    <description>关于个人成长历程、ROS设计 | Carl Zhang，About personal growth, ROS designer. | 这里是 @Playfish 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 13 May 2018 08:17:47 -0700</pubDate>
    <lastBuildDate>Sun, 13 May 2018 08:17:47 -0700</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>【ROS总结】发布ROS2包到ROS版本</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80075689&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在上一总结中，讲述了如何将&lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80039148&quot;&gt;ROS1的包发布到ROS版本&lt;/a&gt;（Indigo、jade、kinetic、lunar等），在这一节中，讲述如何把ROS2的包发送到ROS社区，比如发布到ROS2版本（ardent）。&lt;/p&gt;

&lt;p&gt;这个页面描述了如何准备在公共ROS 2 buildfarm上发布存储库。在你创建了一个包之后，这是将你的包引入到公开可用的Debian软件包(即：你将能够通过apt-get安装包。这个页面包含了ROS 2特定的指令，它取代了在ROS Wiki上的&lt;a href=&quot;http://wiki.ros.org/cn/bloom/Tutorials/FirstTimeRelease&quot;&gt;Bloom发布教程的第2部分&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;注意：早期的ROS 2版本的发布过程主要依赖于&lt;code class=&quot;highlighter-rouge&quot;&gt;git-bloom-release&lt;/code&gt;的子命令&lt;code class=&quot;highlighter-rouge&quot;&gt;bloom-release&lt;/code&gt;，而不是完整的开放版本工作流，所以可能会有问题。&lt;/p&gt;

&lt;h2 id=&quot;对比ros1-bloom不同&quot;&gt;对比ROS1 bloom不同&lt;/h2&gt;

&lt;p&gt;如果你在ROS1之前使用bloom发布过ROS包，ROS2的先决条件和ROS1差不多。然而，ROS 2还没有为你自动进行标记和版本控制的工具（没有等价于&lt;code class=&quot;highlighter-rouge&quot;&gt;catkin_create_changelog&lt;/code&gt;工具）。&lt;/p&gt;

&lt;h3 id=&quot;要求工具&quot;&gt;要求工具&lt;/h3&gt;

&lt;p&gt;对于ROS2的Ardent来说：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;bloom &amp;gt;= 0.6.2&lt;/li&gt;
  &lt;li&gt;catkin_pkg &amp;gt;= 0.4.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;过程&quot;&gt;过程&lt;/h3&gt;

&lt;h4 id=&quot;第一步changelog可选&quot;&gt;第一步：changelog（可选）&lt;/h4&gt;

&lt;p&gt;创建/更新CHANGELOG.rst，使用即将到来的新格式。注意，changelog严格来说是可选的，但它是非常推荐的。&lt;/p&gt;

&lt;p&gt;注意你的changelog格式中的错误可能会导致你的包发布问题。提交并将更改提交给变更日志。&lt;/p&gt;

&lt;h4 id=&quot;第二步标记包版本号&quot;&gt;第二步：标记包版本号&lt;/h4&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package.xml&amp;gt;&lt;/code&gt;中更新包的版本。版本号必须比前一个版本高。对于你的第一个版本，我们建议0.0.1或1.0.0。提交并推动这个变更。&lt;/p&gt;

&lt;p&gt;注意，你不能使用以前使用的版本号(参见下面)。一些包释放到ROS 1和ROS 2，但是由于这个需求，必须使用不同的版本控制系列。ROS包通常不遵循严格的&lt;a href=&quot;https://semver.org/&quot;&gt;语义版本&lt;/a&gt;控制，所以不要过分担心。如果你想了解其他人已经做了什么，请使用ROS 1发布包中的0.x.x或1.x.x系列和ROS 2发布包中的1.x.x或2.x.x系列。&lt;/p&gt;

&lt;h4 id=&quot;第三步标记你的包&quot;&gt;第三步：标记你的包&lt;/h4&gt;

&lt;p&gt;创建一个与你刚刚输入到package.xml中的版本号相匹配的标记，在提交时，会遇到版本号。现在你知道了不能重用版本号的原因——git只允许在存储库中使用给定名称的一个标记。&lt;/p&gt;

&lt;h4 id=&quot;第四步确保你的bloom和catkin_pkg是最新版本&quot;&gt;第四步：确保你的bloom和catkin_pkg是最新版本&lt;/h4&gt;

&lt;p&gt;查看以上版本要求，运行以下命令追踪当前版本：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install python-catkin-pkg python-bloom 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;第五步设置ros-2环境变量&quot;&gt;第五步：设置ROS 2环境变量&lt;/h4&gt;

&lt;p&gt;ROS 2使用的是全新的存储库，该版本的所有索引保存在https://github.com/ros2/rosdistro，forked该存储库。你可以通过设置ROSDISTRO_INDEX_URL环境变量来配置bloom。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ROSDISTRO_INDEX_URL='https://raw.githubusercontent.com/ros2/rosdistro/ros2/index.yaml'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;导出这个之后，你将能够在你的bloom-release终端命令中使用ROS 2发行版的&lt;code class=&quot;highlighter-rouge&quot;&gt;ardent&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bouncy&lt;/code&gt;等名称。&lt;/p&gt;

&lt;h3 id=&quot;下一步&quot;&gt;下一步&lt;/h3&gt;

&lt;p&gt;现在，你的存储库设置完毕。你已经手动完成ROS 2在&lt;a href=&quot;http://wiki.ros.org/cn/bloom/Tutorials/PrepareUpstream&quot;&gt;这个界面&lt;/a&gt;的内容&lt;/p&gt;

&lt;p&gt;返回到ROS Wiki上的&lt;a href=&quot;http://wiki.ros.org/cn/bloom/Tutorials/FirstTimeRelease&quot;&gt;Bloom发布&lt;/a&gt;教程，并继续“创建一个发布存储库”。&lt;/p&gt;

</description>
        <pubDate>Wed, 25 Apr 2018 04:40:44 -0700</pubDate>
        <link>http://localhost:4000/2018/04/25/releaseros2-into-rosdistro/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/25/releaseros2-into-rosdistro/</guid>
        
        <category>ROS2</category>
        
        <category>Release</category>
        
        
      </item>
    
      <item>
        <title>【ROS总结】发布ROS1包之文档编写</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80041201&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在上一节中，讲述了如何发布一个包到ROS社区，这一节将讲述，如何在wiki界面编写ROS包说明文档、教程。&lt;/p&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;登录wiki官网，创建界面编辑账号&lt;/li&gt;
  &lt;li&gt;向ROS社区提交wiki页面编辑权限，取得白名单&lt;/li&gt;
  &lt;li&gt;编辑ROS包文档&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;创建wiki账号&quot;&gt;创建wiki账号&lt;/h2&gt;

&lt;p&gt;登录wiki.ros.org，选择登录，创建账户&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-with-document/wiki_login.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入用户名密码
&lt;img src=&quot;/img/in-post/release-ros1-with-document/wiki_create_account.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建完成后，选择登录，登录成功会将显示：
&lt;img src=&quot;/img/in-post/release-ros1-with-document/wiki_whitelists.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击界面获取白名单。&lt;/p&gt;

&lt;h2 id=&quot;wiki白名单&quot;&gt;wiki白名单&lt;/h2&gt;

&lt;p&gt;在github上，登录当前github账号，在白名单注册界面：https://github.com/ros-infrastructure/roswiki/issues/139&lt;/p&gt;

&lt;p&gt;发布请求，比如我的wiki用户为playfish，输入，comment即可。
&lt;img src=&quot;/img/in-post/release-ros1-with-document/get_whitelists.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果一切正常，大家可以登录http://wiki.ros.org/UserGroup，查看自己的名字是否加入。&lt;/p&gt;

&lt;h2 id=&quot;编辑文档&quot;&gt;编辑文档&lt;/h2&gt;

&lt;p&gt;现在编写自己ROS包的使用文档，该文档地址应当在package.xml里面表明，比如我的cht10_node包的package.xml地址为：
&lt;img src=&quot;/img/in-post/release-ros1-with-document/package_xml.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此，输入当前第一个网址 http://ros.org/wiki/cht10_node&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-with-document/package_template.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击packageTemplate，来创建界面。
&lt;img src=&quot;/img/in-post/release-ros1-with-document/write_wiki.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在packageHeader中添加自己的cht10_node包名，该界面会自动链接到cht10_node包。&lt;/p&gt;

&lt;p&gt;创建完成后，即可生成界面，文档编辑结束。&lt;/p&gt;

</description>
        <pubDate>Sun, 22 Apr 2018 11:35:30 -0700</pubDate>
        <link>http://localhost:4000/2018/04/22/releaseros1-with-document/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/22/releaseros1-with-document/</guid>
        
        <category>ROS1</category>
        
        <category>Release</category>
        
        <category>Document</category>
        
        <category>wiki</category>
        
        
      </item>
    
      <item>
        <title>【ROS总结】发布ROS1包到ROS版本</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80039148&quot;&gt;CSDN&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在ROS开发过程中，想要发布自己的包贡献到ROS社区，也就是想要自己的包可以通过apt-get的形式进行下载，这样可以避免每次源码编译的时候会遇到很多坑的情况，不过想要发布ROS包到ROS社区需要如下能力：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;长期维护能力：ROS包会一直迭代更新，因此自己的包也应具有长期维护能力，当然，稳定版本后可以不用长期维护。&lt;/li&gt;
  &lt;li&gt;开源精神：因为ROS包遵循BSD协议，会要求将包开源后才可以上传到ROS社区，所以将自己的包发布到ROS社区，最好有开源精神。&lt;/li&gt;
  &lt;li&gt;文档更新：包的更新也伴随这文档更新，当然也不是绝对的，不过最好有包的使用文档，也就是wiki上。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果以上的可以做到，那么，恭喜你，可以作为开源成员加入到ROS大家庭来，开源自己代码，共享社区。&lt;/p&gt;

&lt;p&gt;本教程只是单纯的介绍如何发布自己的包到ROS社区，并且，发布后如何通过apt-get获取下载，关于文档界面编写，也就是wiki说明，会在后面进行说明。&lt;/p&gt;

&lt;p&gt;一般发布自己ROS包有如下步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;具有github账号与要发布的存储库地址，发布存储库(bloom-release生成的包路径)，wiki白名单(文档界面做准备)&lt;/li&gt;
  &lt;li&gt;发布前准备工作，bloom安装(ROS1推荐使用bloom-release进行一键操作)&lt;/li&gt;
  &lt;li&gt;同步到ROS社区&lt;/li&gt;
  &lt;li&gt;等待ROS社区的ROS包版本迭代&lt;/li&gt;
  &lt;li&gt;编辑wiki文档教程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上步骤完成后，就可以进行apt-get形式下载自己的包了。假如自己的包为cht10_node，那么可以使用如下命令进行安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install ros-&amp;lt;rosdistro&amp;gt;-cht10-node 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中将&lt;rosdistro&gt;替换成自己的ROS版本，也就是自己的包发布到的ROS版本中，比如自己的包发布到了kinetic中，那么就是：&lt;/rosdistro&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo  apt-get  install ros-kinetic-cht10-node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意：并不是自己把包发布到ROS社区就等于所有的ROS版本都可以下载，只有发布到对应ROS版本才可以。也就是说要想把自己的包发布到ROS所有版本，必须把自己的包发布到所有的版本中，比如Indigo、Jade、Kinetic、Luna、Melodic中。&lt;/p&gt;

&lt;p&gt;ROS发布需要bloom-release包，我已经将ROS的bloom-release包如何使用翻译到wiki上，大家可以查看教程&lt;/p&gt;

&lt;p&gt;http://wiki.ros.org/cn/bloom&lt;/p&gt;

&lt;p&gt;或者查看英文教程：&lt;/p&gt;

&lt;p&gt;http://wiki.ros.org/bloom&lt;/p&gt;

&lt;p&gt;以后会编写如何发布ROS2的包到ROS社区教程。&lt;/p&gt;

&lt;p&gt;大家也可以看Mastering ROS for Robotics Programming中的Maintaining the ROS package 部分。&lt;/p&gt;

&lt;p&gt;Mastering ROS for Robotics Programming书籍下载：https://download.csdn.net/download/u011118482/10402380 (包含英文和中文翻译)。&lt;/p&gt;

&lt;p&gt;没有0积分下载，大家也可以进入ROS群进行下载。&lt;/p&gt;

&lt;h2 id=&quot;发布前的准备&quot;&gt;发布前的准备&lt;/h2&gt;

&lt;h3 id=&quot;创建github存储库&quot;&gt;创建github存储库&lt;/h3&gt;

&lt;p&gt;登录http://github.com/，创建自己的github账号，创建完成后，创建要发布的ROS存储库，例如包名为之前教程的cht10_node，那么创建cht10_node目录。&lt;/p&gt;

&lt;p&gt;我的存储库为：https://github.com/Playfish/cht10_node&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/cht10_repo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建完成后，上传自己的代码到github的cht10_node存储库中。完成如上图。&lt;/p&gt;

&lt;p&gt;注意：发布ROS包应有如下内容，否则无法发布：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CHANGELOG.rst：必须有该文件，该文件内容，可以查看我写的，格式一般为包+版本(日期)+分隔符+修订日志&lt;/li&gt;
  &lt;li&gt;package.xml：内容必须有maintainer子项，版本号必须与CHANGELOG中的版本一致，比如都为0.0.1，包名也一样。&lt;/li&gt;
  &lt;li&gt;tag：版本标记。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;生成tag用于以下发布ROS包追踪：&lt;/p&gt;

&lt;p&gt;点击当前界面上的release按钮，创建一个release tag：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/cht10_release.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;保存。&lt;/p&gt;

&lt;h3 id=&quot;创建github-release存储库&quot;&gt;创建github release存储库&lt;/h3&gt;

&lt;p&gt;创建要发布的ROS完成后，为ROS包创建生成的release存储库，我创建的名为cht10_node_release，最好创建为包名_release。这个存储库为空即可，必须勾选初始化ReadeMe.md选项，生成的包版本更新日志将存放在这里。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/cht10_release_repo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完成后即可，不用再管这个存储库，后期发布完成后，可以查看内容。&lt;/p&gt;
&lt;h3 id=&quot;fork-ros社区版本包存储库&quot;&gt;fork ROS社区版本包存储库&lt;/h3&gt;

&lt;p&gt;保证自己的github账号处于登录状态，点击：http://github.com/ros/rosdistro 。随后点击fork。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/fork_rosdistro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完成后，可以看到自己有了rosdistro存储库：
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/playfish_rosdistro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;发布ros包&quot;&gt;发布ROS包&lt;/h2&gt;
&lt;p&gt;发布前的准备完成后，在自己的Ubuntu下，安装bloom_release包，安装命令如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install python-bloom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装完成后，使用如下命令进行发布：&lt;/p&gt;

&lt;p&gt;以下配置只会在第一次产生。&lt;/p&gt;

&lt;p&gt;运行以下命令进行发布与配置ROS Release包，比如把cht10_node发布到kinetic版本上：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bloom-release --rosdistro kinetic --track kinetic cht10_node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中–rosdistro后的选项为发布到kinetic版本，–track选项为追踪选项，默认为ROS分布式版本，最后的cht10_node为当前存储库名称。&lt;/p&gt;

&lt;p&gt;运行命令产生如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入之前创建的发布的release存储库：https://github.com/Playfish/cht10_node_release.git&lt;/p&gt;

&lt;p&gt;选择Y确定创建追踪。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入当前存储库名称：cht10_node&lt;/p&gt;

&lt;p&gt;输入当前存储库地址：https://github.com/Playfish/cht10_node.git&lt;/p&gt;

&lt;p&gt;随后一路按下回车为默认选项。直到遇到输入用户名、密码为止，在此过程中会遇到很多次输入账号密码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入github账号密码，回车。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;产生debian配置文件：y&lt;/p&gt;

&lt;p&gt;输入当前github用户名密码继续。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;产生debian包后，输入用户名密码发布tag。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;编辑当前ROS包另一个配置，文档配置以及版本状态，输入默认即可。&lt;/p&gt;

&lt;p&gt;注意：turn on pull request testing选择默认为N，如果选择y需要额外配置，不需要打开，我这里是为以后做准备。&lt;/p&gt;

&lt;p&gt;额外的配置查看：https://github.com/ros/rosdistro/pull/17576&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;向rosdistro存储库的kinetic目录下的分布式文件添加当前包内容。&lt;/p&gt;

&lt;p&gt;随后向rosdistro存储库提交请求，输入当前github账号密码。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;生成请求日志。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/release_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完成后，将提示已经发布完成请求，大家可以点击最后的链接查看当前请求。&lt;/p&gt;
&lt;h2 id=&quot;确认工作&quot;&gt;确认工作&lt;/h2&gt;

&lt;p&gt;请求完成后，大家打开之前创建的空白发布存储库，可以看到已经生成了很多生成deb包的规则文件，例如我的：&lt;/p&gt;

&lt;p&gt;https://github.com/Playfish/cht10_node_release.git&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/cht10_release_fill.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大家可以到https://github.com/ros/rosdistro/pulls，查看发布情况。
&lt;img src=&quot;/img/in-post/release-ros1-into-rosdistro/report_rosdistro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果一切正常，ROS维护人员将合并当前请求，合并完成后。&lt;/p&gt;

&lt;p&gt;到 讨论论坛中https://discourse.ros.org/查看当前版本下的包迭代情况，一般为一个月ROS包版本迭代一次。&lt;/p&gt;

&lt;p&gt;迭代完成后，可以看到自己的包已经存放到了http://packages.ros.org下。&lt;/p&gt;

&lt;p&gt;使用apt-get update 更新后，可以下载自己的包了，比如我的包可以用如下命令下载：&lt;/p&gt;

&lt;p&gt;sudo  apt-get  install  ros-kinetic-cht10-node&lt;/p&gt;

&lt;p&gt;ROS包的发布过程这一节告一段落，下一步讲述如何&lt;a href=&quot;https://blog.csdn.net/u011118482/article/details/80041201&quot;&gt;编辑cht10_node生成的wiki文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;注意，如果要生成wiki文档，需要在package.xml里面添加url指向wiki。&lt;/p&gt;

</description>
        <pubDate>Sun, 22 Apr 2018 10:48:13 -0700</pubDate>
        <link>http://localhost:4000/2018/04/22/releaseros1-into-rosdistro/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/22/releaseros1-into-rosdistro/</guid>
        
        <category>ROS1</category>
        
        <category>Release</category>
        
        
      </item>
    
      <item>
        <title>饿了么的 PWA 升级实践</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;很荣幸在今年 2 月到 5 月的时间里，以顾问的身份加入饿了么，参与 PWA 的相关工作。这篇文章其实最初是在以英文写作发表在 medium 上的：&lt;a href=&quot;https://medium.com/elemefe/upgrading-ele-me-to-progressive-web-app-2a446832e509&quot;&gt;Upgrading Ele.me to Progressive Web Apps&lt;/a&gt;，获得了一定的关注。所以也决定改写为中文版本再次分享出来，希望能对你有所帮助 ;) &lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;http://geek.csdn.net/news/detail/210535&quot;&gt;CSDN&lt;/a&gt; 与《程序员》2017 年 7 月刊，同步发布于 &lt;a href=&quot;https://zhuanlan.zhihu.com/ElemeFE&quot;&gt;饿了么前端 - 知乎专栏&lt;/a&gt;、&lt;a href=&quot;https://huangxuan.me&quot;&gt;Hux Blog&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;自 Vue.js 官方推特第一次&lt;a href=&quot;https://twitter.com/vuejs/status/834087199008239619&quot;&gt;公开&lt;/a&gt;到现在，我们就一直在进行着将&lt;a href=&quot;https://h5.ele.me/msite/#pwa=true&quot;&gt;饿了么移动端网站&lt;/a&gt;升级为 &lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot;&gt;Progressive Web App&lt;/a&gt; 的工作。直到近日在 Google I/O 2017 上&lt;a href=&quot;https://m.weibo.cn/status/4109332495285652&quot;&gt;登台亮相&lt;/a&gt;，才终于算告一段落。我们非常荣幸能够发布全世界第一个专门面向国内用户的 PWA，但更荣幸的是能与 Google、UC 以及腾讯合作，一起推动国内 web 与浏览器生态的发展。&lt;/p&gt;

&lt;h2 id=&quot;多页应用vuepwa&quot;&gt;多页应用、Vue、PWA？&lt;/h2&gt;

&lt;p&gt;对于构建一个希望达到原生应用级别体验的 PWA，目前社区里的主流做法都是采用 SPA，即单页面应用模型（Single-page App）来组织整个 web 应用，业内最有名的几个 PWA 案例 &lt;a href=&quot;https://blog.twitter.com/2017/how-we-built-twitter-lite&quot;&gt;Twitter Lite&lt;/a&gt;、 &lt;a href=&quot;https://medium.com/progressive-web-apps/building-flipkart-lite-a-progressive-web-app-2c211e641883&quot;&gt;Flipkart Lite&lt;/a&gt;、&lt;a href=&quot;https://medium.com/engineering-housing/progressing-mobile-web-fac3efb8b454&quot;&gt;Housing Go&lt;/a&gt; 与 &lt;a href=&quot;https://shop.polymer-project.org/&quot;&gt;Polymer Shop&lt;/a&gt; 无一例外。&lt;/p&gt;

&lt;p&gt;然而饿了么，与很多国内的电商网站一样，青睐多页面应用模型（MPA，Multi-page App）所能带来的一些好处，也因此在一年多将移动站从基于 Angular.js 的单页应用重构为目前的多页应用模型。团队最看重的优点莫过于页面与页面之间的隔离与解耦，这使得我们可以将每个页面当做一个独立的“微服务”来看待，这些服务可以被独立迭代，独立提供给各种第三方的入口嵌入，甚至被不同的团队独立维护。而整个网站则只是各种服务的集合而非一个巨大的整体。&lt;/p&gt;

&lt;p&gt;与此同时，我们仍然依赖 &lt;a href=&quot;http://vuejs.org/&quot;&gt;Vue.js&lt;/a&gt; 作为 JavaScript 框架。Vue 除了是 React/Angular 这种“重型武器”的竞争对手外，其轻量与高性能的优点使得它同样可以作为传统多页应用开发中流行的 “jQuery/Zepto/Kissy + 模板引擎” 技术栈的完美替代。Vue 提供的组件系统、声明式与响应式编程更是提升了代码组织、共享、数据流控制、渲染等各个环节的开发效率。&lt;a href=&quot;(https://www.youtube.com/watch?v=pBBSp_iIiVM)&quot;&gt;Vue 还是一个渐进式框架&lt;/a&gt;，如果网站的复杂度继续提升，我们可以按需、增量地引入 Vuex 或 Vue-Router 这些模块。万一哪天又要改回单页呢？（谁知道呢……）&lt;/p&gt;

&lt;p&gt;2017 年，PWA 已经成为 web 应用新的风潮。我们决定试试，以我们现有的“Vue + 多页”的架构，能在升级 PWA 的道路上走多远，达到怎样的效果。&lt;/p&gt;

&lt;h2 id=&quot;实现-prpl-模式&quot;&gt;实现 “PRPL” 模式&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/prpl-pattern/&quot;&gt;“PRPL”&lt;/a&gt;（读作 “purple”）是 Google 的工程师提出的一种 web 应用架构模式，它旨在利用现代 web 平台的新技术以大幅优化移动 web 的性能与体验，对如何组织与设计高性能的 PWA 系统提供了一种高层次的抽象。我们并不准备从头重构我们的 web 应用，不过我们可以把实现 “PRPL” 模式作为我们的迁移目标。“PRPL”实际上是 Push/Preload、Render、Precache、Lazy-Load 的缩写，我们会在下文中展开它们的具体含义。&lt;/p&gt;

&lt;h3 id=&quot;1-pushpreload推送预加载初始-url-路由所需的关键资源&quot;&gt;1. PUSH/PRELOAD，推送/预加载初始 URL 路由所需的关键资源。&lt;/h3&gt;

&lt;p&gt;无论是 HTTP2 Server Push 还是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;link rel=&quot;preload&quot;&amp;gt;&lt;/code&gt;，其关键都在于，我们希望提前请求一些隐藏在应用依赖关系（Dependency Graph）较深处的资源，以节省 HTTP 往返、浏览器解析文档、或脚本执行的时间。比如说，对于一个基于路由进行 code splitting 的 SPA，如果我们可以在 webpack 清单、路由等入口代码（entry chunks）被下载与运行之前就把初始 URL，即用户访问的入口 URL 路由所依赖的代码用 Server Push 推送或 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;link rel=&quot;preload&quot;&amp;gt;&lt;/code&gt; 进行提前加载。那么当这些资源被真正请求时，它们可能已经下载好并存在在缓存中了，这样就加快了初始路由所有依赖的就绪。&lt;/p&gt;

&lt;p&gt;在多页应用中，每一个路由本来就只会请求这个路由所需要的资源，并且通常依赖也都比较扁平。饿了么移动站的大部分脚本依赖都是普通的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 元素，因此他们可以在文档解析早期就被浏览器的 preloader 扫描出来并且开始请求，其效果其实与显式的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;link rel=&quot;preload&quot;&amp;gt;&lt;/code&gt; 是一致的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/PUSH-link-rel-preload.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们还将所有关键的静态资源都伺服在同一域名下（不再做域名散列），以更好的利用 HTTP2 带来的多路复用（Multiplexing）。同时，我们也在进行着对 API 进行 Server Push 的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26757514&quot;&gt;实验&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2-render渲染初始路由尽快让应用可被交互&quot;&gt;2. RENDER，渲染初始路由，尽快让应用可被交互&lt;/h3&gt;

&lt;p&gt;既然所有初始路由的依赖都已经就绪，我们就可以尽快开始初始路由的渲染，这有助于提升应用诸如首次渲染时间、可交互时间等指标。多页应用并不使用基于 JavaScript 的路由，而是传统的 HTML 跳转机制，所以对于这一部分，多页应用其实不用额外做什么。&lt;/p&gt;

&lt;h3 id=&quot;3-pre-cache用-service-worker-预缓存剩下的路由&quot;&gt;3. PRE-CACHE，用 Service Worker 预缓存剩下的路由&lt;/h3&gt;

&lt;p&gt;这一部分就需要 &lt;a href=&quot;https://w3c.github.io/ServiceWorker/v1/&quot;&gt;Service Worker&lt;/a&gt; 的参与了，Service Worker 是一个位于浏览器与网络之间的客户端代理，它以可拦截、处理、响应流经的 HTTP 请求，使得开发者得以从缓存中向 web 应用提供资源而闻名。不过，Service Worker 其实也可以主动发起 HTTP 请求，在“后台” 预请求与预缓存我们未来所需要的资源。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/PRECACHE-future-routes.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们已经使用 &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; 在构建过程中进行 &lt;code class=&quot;highlighter-rouge&quot;&gt;.vue&lt;/code&gt; 编译、文件名哈希等工作，于是我们编写了一个 webpack 插件来帮助我们收集需要缓存的依赖到一个“预缓存清单”中，并使用这个清单在每次构建时生成新的 Service Worker 文件。在新的 Service Worker 被激活时，清单里的资源就会被请求与缓存，这其实与 &lt;a href=&quot;https://medium.com/@Huxpro/how-does-sw-precache-works-2d99c3d3c725&quot;&gt;SW-Precache 这个库的运行机制&lt;/a&gt;非常接近。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实际上，我们只对我们标记为“关键路由”的路由进行依赖收集。&lt;/strong&gt;你可以将这些“关键路由”的依赖理解为我们整个应用的 &lt;a href=&quot;https://developers.google.com/web/updates/2015/11/app-shell&quot;&gt;“App Shell”&lt;/a&gt; 或者说“安装包”。一旦它们都被缓存，或者说成功安装，无论用户是在线离线，我们的 web 应用都可以从缓存中直接启动。对于那些并不那么重要的路由，我们则采取在运行时增量缓存的方式。我们使用的 &lt;a href=&quot;https://googlechrome.github.io/sw-toolbox/&quot;&gt;SW-Toolbox&lt;/a&gt; 提供了 LRU 替换策略与 TTL 失效机制，可以保证我们的应用不会超过浏览器的缓存配额。&lt;/p&gt;

&lt;h3 id=&quot;4-lazy-load-按需懒加载懒实例化剩下的路由&quot;&gt;4. LAZY-LOAD 按需懒加载、懒实例化剩下的路由&lt;/h3&gt;

&lt;p&gt;懒加载与懒实例化剩下的路由对于 SPA 是一件相对麻烦点儿的事情，你需要实现基于路由的 code splitting 与异步加载。幸运的是，这又是一件不需要多页应用担心的事情，多页应用中的各个路由天生就是分离的。&lt;/p&gt;

&lt;p&gt;值得说明的是，无论单页还是多页应用，如果在上一步中，我们已经将这些路由的资源都预先下载与缓存好了，那么懒加载就几乎是瞬时完成的了，这时候我们就只需要付出实例化的代价。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;这四句话即是 PRPL 的全部了。有趣的是，我们发现多页应用在实现 PRPL 这件事甚至比单页还要容易一些。那么结果如何呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/Lighthouse-before.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据 Google 推出的 Web 性能分析工具 Lighthouse（v1.6），在模拟的 3G 网络下，用户的初次访问（无任何缓存）大约在 2 秒左右达到“可交互”，可以说非常不错。而对于再次访问，由于所有资源都直接来自于 Service Worker 缓存，页面可以在 1 秒左右就达到可交互的状态了。&lt;/p&gt;

&lt;p&gt;但是，故事并不是这么简单得就结束了。在实际的体验中我们发现，&lt;strong&gt;应用在页与页的切换时，仍然存在着非常明显的白屏空隙&lt;/strong&gt;，由于 PWA 是全屏运行的，白屏对用户体验所带来的负面影响甚至比以往在浏览器内更大。我们不是已经用 Service Worker 缓存了所有资源了吗，怎么还会这样呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/before-skeleton.jpg&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;从首页点击到发现页，跳转过程中的白屏&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;多页应用的陷阱重启开销&quot;&gt;多页应用的陷阱：重启开销&lt;/h2&gt;

&lt;p&gt;与 SPA 不同，在多页应用中，路由的切换是原生的浏览器文档跳转（Navigating across documents），这意味着之前的页面会被完全丢弃而浏览器需要为下一个路由的页面重新执行所有的启动步骤：重新下载资源、重新解析 HTML、重新运行 JavaScript、重新解码图片、重新布局页面、重新绘制……即使其中的很多步骤本是可以在多个路由之间复用的。这些工作无疑将产生巨大的计算开销，也因此需要付出相当的时间成本。&lt;/p&gt;

&lt;p&gt;图中为我们的入口页（同时也是最重的页面）在 2 倍 CPU 节流模拟下的 profile 数据。即使我们可以将“可交互时间”控制在 1 秒左右，我们的用户仍然会觉得这对于“仅仅切换个标签”来说实在是太慢了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/msite-Before-Optim.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;巨大的-javascript-重启开销&quot;&gt;巨大的 JavaScript 重启开销&lt;/h3&gt;

&lt;p&gt;根据 Profile，我们发现在首次渲染（First Paint）发生之前，大量的时间（900 毫秒）都消耗在了 JavaScript 的运行上（Evaluate Script）。几乎所有脚本都是阻塞的（Parser-blocking），不过因为所有的 UI 都是由 JavaScript/Vue 驱动的，倒也不会有性能影响。这 900ms 中，约一半是消耗在包括 Vue 运行时、组件、库等依赖的运行上，而另一半则花在了业务组件实例化时 Vue 的启动与渲染上。从软件工程角度来说，我们需要这些抽象，所以这里并不是想责怪 JavaScript 或是 Vue 所带来的开销。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是，在 SPA 中，JavaScript 的启动成本是均摊到整个生命周期的：&lt;/strong&gt; 每个脚本都只需要被解析与编译一次，诸如生成 Virtual DOM 等较重的任务可以只执行一次，像 Vue 的 ViewModel 或是 Virtual DOM 这样的大对象也可以被留在内存里复用。&lt;strong&gt;可惜在多页应用里就不是这样了，我们每次切换页面都为 JavaScript 付出了巨大的重启代价。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;浏览器的缓存啊能不能帮帮忙&quot;&gt;浏览器的缓存啊，能不能帮帮忙？&lt;/h3&gt;

&lt;p&gt;能，也不能。&lt;/p&gt;

&lt;p&gt;V8 提供了&lt;a href=&quot;http://v8project.blogspot.com/2015/07/code-caching.html&quot;&gt;代码缓存（code caching）&lt;/a&gt;，可以将编译后的机器码在本地拷贝一份，这样我们就可以在下次请求同一个脚本时一次省略掉请求、解析、编译的所有工作。而且，对于缓存在 Service Worker 配套的 Cache Storage 中的脚本，会在第一次执行后就触发 V8 的代码缓存，这对于我们的多页切换能提供不少帮助。&lt;/p&gt;

&lt;p&gt;另外一个你或许听过的浏览器缓存叫做“进退缓存”，Back-Forward Cache，简称 bfcache。浏览器厂商对其的命名各异，Opera 称之为 Fast History Navigation，Webkit 称其为 Page Cache。但是思路都一样，&lt;strong&gt;就是我们可以让浏览器在跳转时把前一页留存在内存中，保留 JavaScript 与 DOM 的状态，而不是全都销毁掉。&lt;/strong&gt;你可以随便找个传统的多页网站在 iOS Safari 上试试，无论是通过浏览器的前进后退按钮、手势，还是通过超链接（会有一些不同），基本都可以看到瞬间加载的效果。&lt;/p&gt;

&lt;p&gt;Bfcache 其实非常适合多页应用。但不幸的是，Chrome 由于内存开销与其多进程架构等原因目前并不支持。Chrome 现阶段仅仅只是用了传统的 HTTP 磁盘缓存，来稍稍简化了一下加载过程而已。对于 Chromium 内核霸占的 Android 生态来说，我们没法指望了。&lt;/p&gt;

&lt;h2 id=&quot;为感知体验奋斗&quot;&gt;为“感知体验”奋斗&lt;/h2&gt;

&lt;p&gt;尽管多页应用面临着现实中的不少性能问题，我们并不想这么快就妥协。一方面，我们尝试尽可能减少在页面达到可交互时间前的代码执行量，比如减少/推迟一些依赖脚本的执行，还有减少初次渲染的 DOM 节点数以节省 Virtual DOM 的初始化开销。另一方面，我们也意识到应用在感知体验上还有更多的优化空间。&lt;/p&gt;

&lt;p&gt;Chrome 产品经理 Owen 写过一篇 &lt;a href=&quot;https://medium.com/@owencm/reactive-web-design-the-secret-to-building-web-apps-that-feel-amazing-b5cbfe9b7c50&quot;&gt;Reactive Web Design: The secret to building web apps that feel amazing&lt;/a&gt;，谈到两种改进感知体验的手段：一是使用骨架屏（Skeleton Screen）来实现瞬间加载；二是预先定义好元素的尺寸来保证加载的稳定。跟我们的做法可以说不谋而合。&lt;/p&gt;

&lt;p&gt;为了消除白屏时间，我们同样引入了尺寸稳定的骨架屏来帮助我们实现瞬间的加载与占位。即使是在硬件很弱的设备上，我们也可以在点击切换标签后立刻渲染出目标路由的骨架屏，以保证 UI 是稳定、连续、有响应的。我录了&lt;a href=&quot;https://youtu.be/K5JBGnMYO1s&quot;&gt;两个&lt;/a&gt;&lt;a href=&quot;https://youtu.be/w1ZbNsHmRjs&quot;&gt;视频&lt;/a&gt;放在 Youtube 上，不过如果你是国内读者，你可以直接访问饿了么移动网站来体验实地的效果 ;) 最终效果如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/after-skeleton.jpg&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;在添加骨架屏后，从发现页点回首页的效果&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这效果本该很轻松的就能实现，不过实际上我们还费了点功夫。&lt;/p&gt;

&lt;h3 id=&quot;在构建时使用-vue-预渲染骨架屏&quot;&gt;在构建时使用 Vue 预渲染骨架屏&lt;/h3&gt;

&lt;p&gt;你可能已经想到了，为了让骨架屏可以被 Service Worker 缓存，瞬间加载并独立于 JavaScript 渲染，我们需要把组成骨架屏的 HTML 标签、CSS 样式与图片资源一并内联至各个路由的静态 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.html&lt;/code&gt; 文件中。&lt;/p&gt;

&lt;p&gt;不过，我们并不准备手动编写这些骨架屏。你想啊，如果每次真实组件有迭代（每一个路由对我们来说都是一个 Vue 组件）我们都需要手动去同步每一个变化到骨架屏的话，那实在是太繁琐且难以维护了。好在，&lt;a href=&quot;https://www.lukew.com/ff/entry.asp?1797&quot;&gt;骨架屏不过是当数据还未加载进来前，页面的一个空白版本而已&lt;/a&gt;。如果我们能将骨架屏实现为真实组件的一个特殊状态 —— “空状态”的话，我们理论上就可以从真实组件中直接渲染出骨架屏来。&lt;/p&gt;

&lt;p&gt;而 Vue 的多才多艺就在这时体现出来了，我们真的可以用 &lt;a href=&quot;https://ssr.vuejs.org/en/&quot;&gt;Vue.js 的服务端渲染模块&lt;/a&gt; 来实现这个想法，不过不是用在真正的服务器上，而是在构建时用它把组件的空状态预先渲染成字符串并注入到 HTML 模板中。你需要调整你的 Vue 组件代码使得它可以在 Node 上执行，有些页面对 DOM/BOM 的依赖一时无法轻易去除得，我们目前只好额外编写一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.shell.vue&lt;/code&gt; 来暂时绕过这个问题。&lt;/p&gt;

&lt;h3 id=&quot;关于浏览器的绘制painting&quot;&gt;关于浏览器的绘制（Painting）&lt;/h3&gt;

&lt;p&gt;HTML 文件中有标签并不意味着这些标签就能立刻被绘制到屏幕上，你必须保证页面的&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/&quot;&gt;关键渲染路径&lt;/a&gt;是为此优化的。很多开发者相信将 script 标签放在 body 的底部就足以保证内容能在脚本执行之前被绘制，这对于能渲染不完整 DOM 树的浏览器（比如桌面浏览器常见的流式渲染）来说可能是成立的。但移动端的浏览器很可能因为考虑到较慢的硬件、电量消耗等因素并不这么做。&lt;strong&gt;不仅如此，即使你曾被告知设为 &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; 的脚本就不会阻塞 HTML 解析了，但这可不意味着浏览器就一定会在执行它们之前进行渲染。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://html.spec.whatwg.org/images/asyncdefer.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先我想澄清的是，根据 &lt;a href=&quot;https://html.spec.whatwg.org/multipage/scripting.html&quot;&gt;HTML 规范 Scripting 章节&lt;/a&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; 脚本是在其请求完成后立刻运行的，因此它本来就可能阻塞到解析。只有 &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt;（且非内联）与最新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;type=module&lt;/code&gt; 被指定为“一定不会阻塞解析”。（不过 &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; 目前也有点小问题……我们稍后会再提到）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;而更重要的是，一个不阻塞 HTML 解析的脚本仍然可能阻塞到绘制。&lt;/strong&gt;我做了一个简化的&lt;strong&gt;“最小多页 PWA”&lt;/strong&gt;（Minimal Multi-page PWA，或 MMPWA）来测试这个问题，：我们在一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;（且确实不阻塞 HTML 解析）脚本中，生成并渲染 1000 个列表项，然后测试骨架屏能否在脚本执行之前渲染出来。下面是通过 USB Debugging 在我的 Nexus 5 真机上录制的 profile：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/thisTick-&amp;amp;-Load.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;是的，出乎意料吗？首次渲染确实被阻塞到脚本执行结束后才发生。究其原因，&lt;strong&gt;如果我们在浏览器还未完成上一次绘制工作之前就过快得进行了 DOM 操作，我们亲爱的浏览器就只好抛弃所有它已经完成的像素，且一直要等待到 DOM 操作引起的所有工作结束之后才能重新进行下一次渲染。&lt;/strong&gt;而这种情况更容易在拥有较慢 CPU/GPU 的移动设备上出现。&lt;/p&gt;

&lt;h3 id=&quot;黑魔法利用-settimeout-让绘制提前&quot;&gt;黑魔法：利用 setTimeout() 让绘制提前&lt;/h3&gt;

&lt;p&gt;不难发现，骨架屏的绘制与脚本执行实际是一个竞态。大概是 Vue 太快了，我们的骨架屏还是有非常大的概率绘制不出来。于是我们想着如何能让脚本执行慢点，或者说，“懒”点。于是我们想到了一个经典的 Hack： &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout(callback, 0)&lt;/code&gt;。我们试着把 MMPWA 中的 DOM 操作（渲染 1000 个列表）放进 &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout(callback, 0)&lt;/code&gt; 里……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/nextTick-&amp;amp;-Load.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当当！首次渲染瞬间就被提前了。如果你熟悉浏览器的&lt;strong&gt;事件循环模型（event loop）&lt;/strong&gt;的话，这招 Hack 其实是通过 setTimeout 的回调把 DOM 操作放到了事件循环的任务队列中以避免它在当前循环执行，这样浏览器就得以在主线程空闲时喘息一下（更新一下渲染）了。如果你想亲手试试 MMPWA 的话，你可以访问 &lt;a href=&quot;https://github.com/Huxpro/mmpwa&quot;&gt;github.com/Huxpro/mmpwa&lt;/a&gt; 或 &lt;a href=&quot;https://huangxuan.me/mmpwa&quot;&gt;huangxuan.me/mmpwa/&lt;/a&gt; 访问代码与 Demo。我把 UI 设计为了 A/B Test 的形式并改为渲染 5000 个列表项来让效果更夸张一些。&lt;/p&gt;

&lt;p&gt;回到饿了么 PWA 上，我们同样试着把 &lt;code class=&quot;highlighter-rouge&quot;&gt;new Vue()&lt;/code&gt; 放到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt; 中。果然，黑魔法再次显灵，骨架屏在每次跳转后都能立刻被渲染。这时的 Profile 看起来是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/msite-After-Optim.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，我们在 400ms 时触发首次渲染（骨架屏），在 600ms 时完成真实 UI 的渲染并达到页面的可交互。你可以拉上去详细对比下优化前后 profile 的区别。&lt;/p&gt;

&lt;h3 id=&quot;被我-defer-的有关-defer-的-bug&quot;&gt;被我 “defer” 的有关 &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; 的 Bug&lt;/h3&gt;

&lt;p&gt;不知道你发现没有，在上图的 Profile 中，我们仍然有不少脚本是阻塞了 HTML 解析的。好吧让我解释一下，由于历史原因，我们确实保留了一部分的阻塞脚本，比如侵入性很强的 &lt;a href=&quot;https://github.com/amfe/lib-flexible&quot;&gt;lib-flexible&lt;/a&gt;，我们没法轻易去除它。不过，profile 里的大部分阻塞脚本实际上都设置了 &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt;，我们本以为他们应该在 HTML 解析完成之后才被执行，结果被 profile 打了一脸。&lt;/p&gt;

&lt;p&gt;我和 &lt;a href=&quot;https://twitter.com/jaffathecake&quot;&gt;Jake Archibald&lt;/a&gt; &lt;a href=&quot;https://twitter.com/Huxpro/status/859842124849827841&quot;&gt;聊了一下&lt;/a&gt;，果然这是 Chrome 的 Bug：&lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; 的脚本被完全缓存时，并没有遵守规范等待解析结束，反而阻塞了解析与渲染。Jake 已经提交在 &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=717979&quot;&gt;crbug&lt;/a&gt; 上了，一起给它投票吧~&lt;/p&gt;

&lt;p&gt;最后，是优化后的 Lighthouse 跑分结果，同样可以看到明显的性能提升。需要说明的是，能影响 Lighthouse 跑分的因素有很多，所以我建议你以控制变量（跑分用的设备、跑分时的网络环境等）的方式来进行对照实验。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/Lighthouse-after.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后附上一张图，这张图当时是做给 Addy Osmani 的 I/O 演讲用的，描述了饿了么 PWA 是如何结合 Vue 来实现多页应用的 PRPL 模式，可以作为一个架构的参考与示意图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/Architecture.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;一些感想&quot;&gt;一些感想&lt;/h2&gt;

&lt;h3 id=&quot;多页应用仍然有很长的路要走&quot;&gt;多页应用仍然有很长的路要走&lt;/h3&gt;

&lt;p&gt;Web 是一个极其多样化的平台。从静态的博客，到电商网站，再到桌面级的生产力软件，它们全都是 Web 这个大家庭的第一公民。而我们组织 web 应用的方式，也同样只会更多而不会更少：多页、单页、Universal JavaScript 应用、WebGL、以及可以预见的 Web Assembly。不同的技术之间没有贵贱，但是适用场景的差距确是客观存在的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/jaffathecake&quot;&gt;Jake&lt;/a&gt; 曾在 &lt;a href=&quot;https://youtu.be/J2dOTKBoTL4?list=PLNYkxOF6rcIBTs2KPy1E6tIYaWoFcG3uj&quot;&gt;Chrome Dev Summit 2016&lt;/a&gt; 上说过 “PWA !== SPA”。可是尽管我们已经用上了一系列最新的技术（PRPL、Service Worker、App Shell……），我们仍然因为多页应用模型本身的缺陷有着难以逾越的一些障碍。多页应用在未来可能会有“bfcache API”、Navigation Transition 等新的规范以缩小跟 SPA 的距离，不过我们也必须承认，时至今日，多页应用的局限性也是非常明显的。&lt;/p&gt;

&lt;h3 id=&quot;而-pwa-终将带领-web-应用进入新的时代&quot;&gt;而 PWA 终将带领 web 应用进入新的时代&lt;/h3&gt;

&lt;p&gt;即使我们的多页应用在升级 PWA 的路上不如单页的那些来得那么闪亮，但是 PWA 背后的想法与技术却实实在在的帮助我们在 web 平台上提供了更好的用户体验。&lt;/p&gt;

&lt;p&gt;PWA 作为&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25167289&quot;&gt;下一代 Web 应用模型&lt;/a&gt;，其尝试解决的是 web 平台本身的根本性问题：对网络与浏览器 UI 的硬依赖。因此，任何 web 应用都可以从中获益，这与你是多页还是单页、面向桌面还是移动端、是用 React 还是 Vue 无关。或许，它还终将改变用户对移动 web 的期待。现如今，谁还觉得桌面端的 web 只是个看文档的地方呢？&lt;/p&gt;

&lt;p&gt;还是那句老话：让我们的用户，也像我们这般热爱 web 吧。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后，感谢饿了么的王亦斯、任光辉、题叶，Google 的 Michael Yeung、DevRel 团队， UC 浏览器团队，腾讯 X5 浏览器团队在这次项目中的合作。感谢尤雨溪、陈蒙迪和 Jake Archibald 在写作过程中给予我的帮助。&lt;/p&gt;

</description>
        <pubDate>Wed, 12 Jul 2017 05:00:00 -0700</pubDate>
        <link>http://localhost:4000/2017/07/12/upgrading-eleme-to-pwa/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/12/upgrading-eleme-to-pwa/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>PWA</category>
        
        
      </item>
    
  </channel>
</rss>
